<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2015.1 (Build 201U)" ts="2014-08-17 22:32:25">
<Class name="iknowAV.Hotels.Loader">
<IncludeCode>%IKPublic</IncludeCode>
<TimeChanged>63416,34988.200443</TimeChanged>
<TimeCreated>63378,61408.462569</TimeCreated>

<Method name="Load">
<Description>
Метод загрузки отзывов в домен.
domName - имя домена
domFolder - папка для создания конфигурации. Содержит словари, блэклисты и т.д.
FromId - Id отзыва, с которого начинать загрузку
ToId - Id отзыва, до которого производить загрузку.
Например, при вызове do ##class(iknowAV.Hotels.loader).Load("Hotels", "C:\Hotels\Russian\", 1, 1000)
метод Load попробует осуществить загрузку отзывов с ID от 1 до 1000</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,domFolder:%String,FromId:%Integer=1,ToId:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Проверяем входные параметры на корректность
	if (((ToId '= 0) & (FromId > ToId)) || (FromId <= 0) || (ToId < 0)) 
	{
		write "Wrong parameters FromID|ToID.", !	
		return $$$ERROR()
	}
	
	write "Loading started at: ", $zdatetime($horolog), !
	
	// Если домен не существует, создаем новый (так же создается конфигуация)
	do ##class(iknowAV.util.main).CreateDomainIfNotExists(domName, domFolder)
	set domId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	// Устанавливаем имя конфигурации	
	#dim confName As %String = "Conf"_domName
	
	set lister = ##class(%iKnow.Source.SQL.Lister).%New(domId)
	#dim initialNumOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)
	
	do lister.SetConfig(confName)
	set loader = ##class(%iKnow.Source.Loader).%New(domId)
	
	// Создаются поля метаданных	
	do ..SetMetaDataFields(domName)	
	// Создаются словари для matching							
	do ##class(iknowAV.util.main).CreateDictionaries(domName)	
	// Формируются черные списки
	do ##class(iknowAV.util.main).CreateBlackLists(domName, "GeneralBlackList")			
	
	// Переменная для хранения текста SQL-запроса
	set myquery = "SELECT ID1 As ID, review_title as Title, hotel_id as HotelId,"_
				  " hotel_name As HotelName, review_text as reviewText, country as Country, resort as Resort,"_
				  " author as Author, travel_date as TravelDate,"_
				  " rating as AuthorRating, rating_comfort as AuthorRatingComfort, rating_food as AuthorRatingFood,"_
				  " rating_hospitality as AuthorRatingHospitality, rating_location as AuthorRatingLocation,"_
				  " rating_service as AuthorRatingService, rating_territory as AuthorRatingTerritory"_ 
				  " FROM Nui.hreview"
	
	// Формируем запрос в соответствии с входными параметрами
	if (ToId > 0) 						{ set myquery = myquery_" Where ID1 >= "_FromId_" AND ID1 <= "_ToId }
	elseif ((FromId > 1) && (ToId = 0)) { set myquery = myquery_" Where ID1 >= "_FromId }
	
	// Формируем Batch
	// =================
	set meta = $lb("Title", "HotelId", "HotelName", "Country", "Resort", "Author", "TravelDate", "AuthorRating", "AuthorRatingComfort", "AuthorRatingFood", "AuthorRatingHospitality", "AuthorRatingLocation", "AuthorRatingService", "AuthorRatingTerritory")
	set data = $lb("reviewText")
	set group = "ID"
	set id = "ID"
	
	set tSC = lister.AddListToBatch(myquery, id, group, data, meta)
    
    if (tSC '= $$$OK) { 
    	write "The lister failed: ",$System.Status.DisplayError(tSC)
    	return tSC 
    }
    // =================
      
    write "Adding List to Batch Complete!", !
     
    // Запускаем обработку 	
    set tSC = loader.ProcessBatch()      
    
    // В случае появления ошибки, прерывать процесс не следует, т.к. ошибки могут носить и безобидный характер.
    if (tSC '= $$$OK) { write "The loader failed: ", $System.Status.DisplayError(tSC) }
    
    // Матчим источники	
    // =======================
    write !, "   matching sources...", !
	
	set tSC = ##class(%iKnow.Matching.MatchingAPI).MatchSources(domId)	
	
	if (tSC = $$$OK) { write "   sources are matched", ! }
	else             { write "Error matching sources", $System.Status.DisplayError(tSC), ! }		
	// =======================
	
	#dim numOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)
	
	// Цикл по всем источникам для заполнения таблицы iknowAV_Hotels_Stat.Review
	for i = initialNumOfSources+1:1:numOfSources 
	{
		set externalId = ##class(%iKnow.Queries.SourceAPI).GetExternalId(domId, i)
		
		// SQL запрос в данном случае не подходит, так как строки при ProcessBatch обрабатываются 
		// параллельно (могут обрабатываться НЕ по порядку)
		set AuthorRating = ##class(%iKnow.Queries.MetadataAPI).GetValue(domId, "AuthorRating", externalId)
		set AuthorRatingComfort = ##class(%iKnow.Queries.MetadataAPI).GetValue(domId, "AuthorRatingComfort", externalId)
		set AuthorRatingFood = ##class(%iKnow.Queries.MetadataAPI).GetValue(domId, "AuthorRatingFood", externalId)
		set AuthorRatingHospitality = ##class(%iKnow.Queries.MetadataAPI).GetValue(domId, "AuthorRatingHospitality", externalId)
		set AuthorRatingLocation = ##class(%iKnow.Queries.MetadataAPI).GetValue(domId, "AuthorRatingLocation", externalId)
		set AuthorRatingService = ##class(%iKnow.Queries.MetadataAPI).GetValue(domId, "AuthorRatingService", externalId)
		set AuthorRatingTerritory = ##class(%iKnow.Queries.MetadataAPI).GetValue(domId, "AuthorRatingTerritory", externalId)
	
		set hotelID = ##class(%iKnow.Queries.MetadataAPI).GetValue(domId, "HotelId", externalId)						
		set SourceId = i
		
		// Добавляем/обноляем запись в iknowAV_Hotels_Stat.Review
		&sql(INSERT OR UPDATE INTO iknowAV_Hotels_Stat.Review 
			 (DomainName, SourceId, AuthorRating, AuthorRatingComfort, AuthorRatingFood,
			  AuthorRatingHospitality, AuthorRatingLocation, AuthorRatingService, AuthorRatingTerritory, HotelId)
			  VALUES (:domName, :SourceId, :AuthorRating, :AuthorRatingComfort, :AuthorRatingFood,
			  :AuthorRatingHospitality, :AuthorRatingLocation, :AuthorRatingService, :AuthorRatingTerritory, :hotelID))
		
		if (SQLCODE '= 0) {
			zw SQLCODE
			write "Error saving review #", i, !
		}	
	}
		
	// Удаляем ненужные больше поля метаданных
	do ##class(%iKnow.Queries.MetadataAPI).RemoveField( domId,"AuthorRating" )
	do ##class(%iKnow.Queries.MetadataAPI).RemoveField( domId,"AuthorRatingComfort" )
	do ##class(%iKnow.Queries.MetadataAPI).RemoveField( domId,"AuthorRatingFood" )
	do ##class(%iKnow.Queries.MetadataAPI).RemoveField( domId,"AuthorRatingHospitality" )
	do ##class(%iKnow.Queries.MetadataAPI).RemoveField( domId,"AuthorRatingLocation" )
	do ##class(%iKnow.Queries.MetadataAPI).RemoveField( domId,"AuthorRatingService" )
	do ##class(%iKnow.Queries.MetadataAPI).RemoveField( domId,"AuthorRatingTerritory" )
	
	write !, "Loading finished at: ", $zdatetime($horolog), !
	
	// Статистика загруженных источников (было, загружено, стало)		
	write !, "Initial Number of Sources: ", initialNumOfSources, !
	write "Sources Added: ", numOfSources - initialNumOfSources, !
	write "Total: ", numOfSources,!
		
	return numOfSources - initialNumOfSources
]]></Implementation>
</Method>

<Method name="SetMetaDataFields">
<Description>
Установка дополнительных полей метаданных для отзывов
domName - имя домена, в котором проводится действие
редактировать совместно с ..RemoveMetaDataFields</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Получаем ID домена
	set domainId = ##class(iknowAV.util.main).GetDomainId(domName)
	
	// Добавляем поля метаданных	
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"Title",,$$$MDDTDATE)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"HotelId",,$$$MDDTSTRING)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"HotelName",,$$$MDDTSTRING)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"Country",,$$$MDDTSTRING)	
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"Resort",,$$$MDDTSTRING)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"Author",,$$$MDDTSTRING)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"TravelDate",,$$$MDDTSTRING)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"AuthorRating",,$$$MDDTSTRING)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"AuthorRatingComfort",,$$$MDDTSTRING)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"AuthorRatingFood",,$$$MDDTSTRING)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"AuthorRatingHospitality",,$$$MDDTSTRING)	
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"AuthorRatingLocation",,$$$MDDTSTRING)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"AuthorRatingService",,$$$MDDTSTRING)
	do ##class(%iKnow.Queries.MetadataAPI).AddField(domainId,"AuthorRatingTerritory",,$$$MDDTSTRING)
	
	write "Metadata fields added.", !
	
	return $$$OK
]]></Implementation>
</Method>

<Method name="RemoveMetaDataFields">
<Description>
Удаление дополнительных полей, используется при обновлении и удалении домена, возвращает число удаленных полей
domName - имя домена, в котором проводится действие
редактировать совместно с ..SetMetaDataFields</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Получаем ID домена
	set domainId = ##class(iknowAV.util.main).GetDomainId(domName)
	
	set tSC = ##class(%iKnow.Queries.MetadataAPI).RemoveField(domainId, "Title")
	set tSC = tSC + ##class(%iKnow.Queries.MetadataAPI).RemoveField(domainId, "HotelId")
	set tSC = tSC + ##class(%iKnow.Queries.MetadataAPI).RemoveField(domainId, "HotelName")
	set tSC = tSC + ##class(%iKnow.Queries.MetadataAPI).RemoveField(domainId, "Country")
	set tSC = tSC + ##class(%iKnow.Queries.MetadataAPI).RemoveField(domainId, "Resort")
	set tSC = tSC + ##class(%iKnow.Queries.MetadataAPI).RemoveField(domainId, "Author")
	set tSC = tSC + ##class(%iKnow.Queries.MetadataAPI).RemoveField(domainId, "TravelDate")
	
	if (tSC = 7) { write "all metadata fields are deleted", ! }
	else { write "errors in deleting metadata fields", ! }
		
	return tSC
]]></Implementation>
</Method>

<Method name="Free">
<Description>
Удаление домена со всем окружением</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^iknowAVDomainFolder(domName)
	#dim confName As %String = "Conf"_domName
	
	// Удаляем поля метаданных
	do ..RemoveMetaDataFields(domName)	
	// Удаляем словари для matching	
	do ##class(iknowAV.util.main).DeleteDictionaries(domName)	
	// Удаляем черные списки		
	do ##class(iknowAV.util.main).DeleteBlackLists(domName, "GeneralBlackList")	
	// Удаляем конфигурацию
	set tSC = ##class(iknowAV.util.main).DeleteConfiguration(confName)
	
	if (tSC '= $$$OK) { write "Cannot delete configuration :", confName, $System.Status.DisplayError(tSC), ! }
	
	// Очищаем таблицы
	&sql(DELETE FROM iknowAV_Hotels_Stat.Review WHERE DomainName = :domName)
	&sql(DELETE FROM iknowAV_Hotels_Stat.Hotel)
	&sql(DELETE FROM iknowAV_Hotels_Stat.ReviewStat)
	&sql(DELETE FROM iknowAV_Hotels_Stat.HotelStat)
	
	set tSC = ##class(iknowAV.util.main).DeleteDomain(domName)
	if (tSC '= $$$OK) { write "Can't delete domain :", domName, $System.Status.DisplayError(tSC), ! }
	
	return tSC
]]></Implementation>
</Method>
</Class>


<Class name="iknowAV.Hotels.Processing.Dictionary">
<IncludeCode>%IKPublic</IncludeCode>
<TimeChanged>63416,80135.055599</TimeChanged>
<TimeCreated>63391,62547.861221</TimeCreated>

<Method name="TeachFMarkersDictionary">
<Description>
Метод по краткому словарю функциональных маркеров формирует полный словарь, куда входят похожие концепты (s#)
domName - имя домена</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	kill ^fmarkers
	
	// Получаем ID домена
	set domainId = ##class(iknowAV.util.main).GetDomainId(domName)	

	// Загрузка исходного файла со словарем функциональных маркеров			
	#dim filenameIn As %String = ^iknowAVDomainFolder(domName)_"fmarkers.txt"
	write "   fmarkers input file... ", filenameIn,!
	#dim streamIn As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
	set status = streamIn.LinkToFile(filenameIn)
	
	set i = 1
			
	// Цикл по строкам файла	
	while '(streamIn.AtEnd) 
	{		
		set line = streamIn.ReadLine()
				
		// проверка строки на комментарий (начинается с !)		
		set checkComment = $piece(line,"!",1,1)
		if (checkComment="")	// комментарий
		{
			set ^fmarkers(i) = line
			set i = i + 1
			continue
		}
		
		// Обработка строки
		set stype = $piece(line,"#",1)
		
		if (stype = "d")		// словарь или категория
		{
			set ^fmarkers(i) = line
			set i = i + 1
			continue
		}
		elseif (stype = "i") 	// подкатегория
		{
			set ^fmarkers(i) = line
			set i = i + 1
			//set markerCategory = $piece(line,"#",2)
			continue
		}
		// Обрабатываем строку с терминами
		elseif (stype="t") 
		{
			// Парсим строку с терминами, разделенными запятой
			set dList = $piece(line,"#",2)
			set j = 1
			
			// Цикл по терминам в строке
			while $piece(dList,",",j)'="" 
			{	
				// $piece(dList,",",j) - текущий термин
				set entityValue = $piece(dList,",",j)
				//set j = j + 1
				
				set ^fmarkers(i) = "t#"_entityValue
				set i = i + 1
				
				// Определяем число похожих концептов в домене
				set lbNumber = ##class(%iKnow.Queries.EntityAPI).GetSimilarCounts(domainId, entityValue)
				
				// первый элемент списка - количество похожих концептов
				set number = $list(lbNumber, 1)	
				
				// Если похожих нет - идем дальше
				if (number = 0) 
				{
					set j = j + 1
					continue
				}
				
				kill similarResult				
				// Получение id для похожих концептов
				set status = ##class(%iKnow.Queries.EntityAPI).GetSimilar(.similarResult, domainId, entityValue, 1, 0, , ,$$$USEWORDS)	
				// $$USENGRAMS $$$USEWORDS
				if '($data(similarResult(1)))
				{ 
					set j = j + 1
					continue 
				}
				
				set k1 = 1
				set p1 = ""
				
				// Цикл по похожим концептам
				for 
				{	
					set p1 = $order(similarResult(p1))	
					quit:(p1 = "")
					
					// Получаем Id похожего концепта
					set similarEntityId = $list(similarResult(k1),1)
					set similarEntity = ##class(%iKnow.Queries.EntityAPI).GetValue(domainId,similarEntityId)
					if (similarEntity'=entityValue)			
					{
						set ^fmarkers(i) = "s#"_similarEntity
						set i = i + 1
					}

					set k2 = 1
					set p2 = ""
					
					if '($data(result(1)))
					{ 
						set k1 = k1 + 1
						continue 
					}
										
					
					set k1 = k1 + 1
				} // for (Similar)
				
				set j = j + 1
			} // While (Line)
				
		}	// elseif (stype="t") 		
		
	} // while ('stream.AtEnd)
		
	write "   Dictionary placed in ^fmarkers [global].", !		
			
	return $$$OK
]]></Implementation>
</Method>

<Method name="TeachEMarkersDictionary">
<Description>
Метод по краткому словарю эмоциональных маркеров формирует полный словарь, куда входят похожие концепты (s#)
domName - имя домена</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	kill ^emarkers
	
	// Получаем ID домена
	set domainId = ##class(iknowAV.util.main).GetDomainId(domName)	
	

	// Загрузка исходного файла со словарем эмоциональных маркеров			
	#dim filenameIn As %String = ^iknowAVDomainFolder(domName)_"emarkers.txt"
	write "   emarkers input file... ", filenameIn,!
	#dim streamIn As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
	set status = streamIn.LinkToFile(filenameIn)
	
	set i = 1
			
	// Цикл по строкам файла	
	while '(streamIn.AtEnd) 
	{		
		set line = streamIn.ReadLine()
				
		// проверка строки на комментарий (начинается с !)		
		set checkComment = $piece(line,"!",1,1)
		if (checkComment="")	// комментарий
		{
			set ^emarkers(i) = line
			set i = i + 1
			continue
		}
		
		// Обработка строки
		set price = $piece(line,"#",1)
		
		// Парсим строку с терминами, разделенными запятой
		set dList = $piece(line,"#",2)
		set j = 1
			
		// Цикл по терминам в строке
		while $piece(dList,",",j)'="" 
		{	
			// $piece(dList,",",j) - текущий термин
			set entityValue = $piece(dList,",",j)
			//set j = j + 1

			set ^emarkers(i) = price_"#"_entityValue
			set i = i + 1
				
			// Определяем число похожих концептов в домене
			set lbNumber = ##class(%iKnow.Queries.EntityAPI).GetSimilarCounts(domainId, entityValue)
				
			// первый элемент списка - количество похожих концептов
			set number = $list(lbNumber, 1)	
				
			// Если похожих нет - идем дальше
			if (number = 0) 
			{
				set j = j + 1
				continue
			}
				
			kill similarResult				
			// Получение id для похожих концептов
			set status = ##class(%iKnow.Queries.EntityAPI).GetSimilar(.similarResult, domainId, entityValue, 1, 0, , ,$$$USEWORDS)	
			// $$USENGRAMS $$$USEWORDS
			if '($data(similarResult(1)))
			{ 
				set j = j + 1
				continue 
			}
				
			set k1 = 1
			set p1 = ""
				
			// Цикл по похожим концептам
			for 
			{	
				set p1 = $order(similarResult(p1))	
				quit:(p1 = "")
				
				// Получаем Id похожего концепта
				set similarEntityId = $list(similarResult(k1),1)
				set similarEntity = ##class(%iKnow.Queries.EntityAPI).GetValue(domainId,similarEntityId)
				if (similarEntity'=entityValue)			
				{
					set ^emarkers(i) = price_"#"_similarEntity
					set i = i + 1
				}

				set k2 = 1
				set p2 = ""
					
				if '($data(result(1)))
				{ 
					set k1 = k1 + 1
					continue 
				}
										
					
				set k1 = k1 + 1
			} // for (Similar)
				
			set j = j + 1
		} // While (Line)
					
	} // while ('stream.AtEnd)

	write "   Dictionary placed in ^emarkers [global].", !
		
	return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="iknowAV.Hotels.Processing.Processing">
<IncludeCode>%IKPublic</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>63416,81083.209728</TimeChanged>
<TimeCreated>63382,63941.777859</TimeCreated>

<Parameter name="NEUTRALLOWBORDER">
<Description>
Параметр, определяющий нижнюю границу оценки отеля (От 0 до 1), при котором отзыв считается нейтральным</Description>
<Default>2.75</Default>
</Parameter>

<Parameter name="NEUTRALHIGHBORDER">
<Description>
Параметр, определяющий верхнюю границу оценки отеля (От 0 до 1), при котором отзыв считается нейтральным</Description>
<Default>3.25</Default>
</Parameter>

<Parameter name="PESSUSPECT">
<Description>
Параметр, отвечающий за оценку подозрительности отзыва (Если PES отзыва выше указанного в параметре значения, 
он считается подозрительным</Description>
<Default>0.99</Default>
</Parameter>

<Parameter name="POSNEGBORDER">
<Description>
Параметр, указывающий границу позитивности и негативности отзыва (Если оценка отзыва выше этой границы - он позитивный)</Description>
<Default>3</Default>
</Parameter>

<Method name="ProcessAllSources">
<Description>
Метод обработки всех источников домена.
В цикле запускает обработку каждого источника указанного домена.
Затем запускает обработку полученных результатов обработки источников для получения конечных оценок отелей.
domName - имя домена.
applyNegation: 1 - цчитывать предложения с Negation, 0 - не учитывать.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,applyNegation:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	set beginTime = $piece($horolog,",",2)
	
	// Получаем ID домена
	set domainId = ##class(iknowAV.util.main).GetDomainId(domName)	
	
	// Обрабатываем словари
	do ##class(iknowAV.Hotels.Processing.Dictionary).TeachEMarkersDictionary(domName)
	do ##class(iknowAV.Hotels.Processing.Dictionary).TeachFMarkersDictionary(domName)
	
	do ..ClearStats(domName)
	// Очищаем таблицу Sentence
	do ..ClearSentences()

	set numberOfSources = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domainId)
	
	// Вычисляем количество групп
	set numberOfGroups = numberOfSources \ 512
	// Вычисляем остаток
	set diff = numberOfSources - (numberOfGroups * 512)
	if (diff '= 0) { set numberOfGroups = numberOfGroups + 1}
	
	set j = 1
	
	write "   Processing sentences.. Please wait.", !
	for m=1:1:numberOfGroups {
		
		set i = 1
		kill srcList
		
		while ((i <= 512) && (j <= numberOfSources)) 
		{
			set $list(srcList, *+1) = j
			set i = i + 1 
			set j = j + 1
		}
		
		
		// Заполняем таблицу Sentence с учетов эмоциональных маркеров
		do ..BuildProcessingSentences(domName, srcList)

		// Обрабатываем Negation
		do ..ProcessNegationSentences(domName, srcList)
		
	}
	
	// Цикл по всем источникам домена
	for srcId=1:1:numberOfSources 
	{
		write !, "Processing SourceID ", srcId, " of ", numberOfSources, !
		// Обрабатываем источник
		do ..ProcessSource(domName, srcId, applyNegation)
	}	
	
	// Обрабатываем источники для получения конечных оценок по отелям
	set tSC = ..ProcessHotelsGrades()
	write !, "Process hotels grades passed with status: ", tSC, !

	set tSC =  ..ProcessingStats(domName, applyNegation)
	write "Processing Emotional Stats complete with status: ", tSC, !
	
	do ..ProcessSuspectAndUsefulness()
	
	set endTime = $piece($horolog,",",2)

	write !, "Elapsed time: ", $ztime(endTime - beginTime), !
	
	return $$$OK
]]></Implementation>
</Method>

<Method name="ProcessSuspectAndUsefulness">
<Description>
Метод, в цикле обрабатывающий все отзывы и расчитывающий для каждого отзыва подозрительность и полезность.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	&sql(SELECT %DLIST(HotelId) INTO :idList FROM iknowAV_Hotels_Stat.Hotel)	
	set length = $listlength(idList)
	
	for i=1:1:length {
		do ..DetectSuspectReviewsByHotel($list(idList, i))
		do ..CalcReviewsUsefulness($list(idList,i))
	}
]]></Implementation>
</Method>

<Method name="ProcessSource">
<Description>
Метод, производящий обработку указанного источника.
domName - имя домена.
srcId - ID источника.
applyNegation - учитывать ли Negation. 1 - да, 0 - нет.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,srcId:%Integer,applyNegation:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	
	// Заполняем таблицу Review с учетом функциональных маркеров
	set tSC = ..ProcessFunctionalMarkers(domName, srcId, applyNegation)
	write "  Process functional markers passed with status: ", tSC,!
]]></Implementation>
</Method>

<Method name="BuildProcessingSentences">
<Description>
Метод анализирует предложения указанного источника на эмоциональные маркеры и заполняет
таблицу iknowAV_Hotels_Processing.Sentence
domName - имя домена.
srcId - ID источника.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,srcList:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Получаем ID домена
	set domainId = ##class(iknowAV.util.main).GetDomainId(domName)	
	
	/*
	set file = "C:\InterSystems\log.txt"
	set stream = ##class(%Stream.FileCharacter).%New()
	do stream.LinkToFile(file)
	*/
		
	set p1 = ""	
		
	for
	{		
		set p1 = $order(^emarkers(p1))
		quit:(p1 = "")	
	
		set line = ^emarkers(p1)
		
		// Проверяем, не начинается ли строка с "!" (! - комментарий)		
		set checkComment = $PIECE(line,"!", 1, 1)
		
		if (checkComment = "") { continue }
		
		// Получаем вес терминов
		set sValue = $piece(line,"#", 1)	
		set entityValue = $piece(line,"#", 2)
		
		// Получаем ID текущей сущности
		set entityId = ##class(%iKnow.Queries.EntityAPI).GetId(domainId, entityValue)	
	
		kill result	
		// Получаем список предложений в источнике, содержащих данный концепт
		do ##class(%iKnow.Queries.SentenceAPI).GetByEntityIds(.result, domainId, $lb(entityId), srcList, 1, 0)	
		
		if '($data(result(1))) { continue }			
		
		set p2 = ""
		
		// Цикл по предложениям, содержащим концепт
		for 
		{					
			set p2 = $order(result(p2))	
			quit:(p2 = "")
			
			// ID предложения в sentenceId		
			set sentenceId = $list(result(p2), 3)	
			
			// Получаем ID предложения в таблице (для открытия объекта)
			&sql(SELECT ID INTO :id FROM  iknowAV_Hotels_Processing.Sentence WHERE SentenceId = :sentenceId AND DomainName = :domName)
			
			// Если SQL-запрос ничего не вернул, то создаем новый объект
			if (SQLCODE = 100) {	
				&sql(INSERT INTO iknowAV_Hotels_Processing.Sentence (DomainName, SentenceId) 
					 VALUES (:domName, :sentenceId))
				set id = ^iknowAV.Hotels.PrE05F.SentenceD
			}
			// Если SQL-запрос вернул нам ID, то открываем объект
			elseif (SQLCODE < 0) {
				write "Error during SQL query.", !
				write "   query returned SQLCODE: ", SQLCODE, !
				return $$$ERROR("SQL query error")	
			}
			
			// Добавляем в соответствующее поле весовое значение 					
			if (sValue = "+1")		{set $list(^iknowAV.Hotels.PrE05F.SentenceD(id),4) = $list(^iknowAV.Hotels.PrE05F.SentenceD(id),4) + 1 } //do stream.WriteLine(sentenceId_"+1"_entityValue)}
			elseif (sValue = "-1")	{set $list(^iknowAV.Hotels.PrE05F.SentenceD(id),5) = $list(^iknowAV.Hotels.PrE05F.SentenceD(id),5) + 1 } //do stream.WriteLine(sentenceId_"-1"_entityValue)}
							
		}	// for (Sentence)
		
	} // while 'stream.AtEnd
	
	/*
	do stream.%Save()
	*/
	
	return $$$OK
]]></Implementation>
</Method>

<Method name="ProcessNegationSentences">
<Description>
Обработка отрицательных предложений
domName - имя домена
srcId - ID источника</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,srcList:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Получаем ID домена
	set domainId = ##class(iknowAV.util.main).GetDomainId(domName)	
	
	// Получаем количество предложений в источнике
	set number = ##class(%iKnow.Queries.SentenceAPI).GetCountBySource(domainId, srcList)
	
	set length = $listlength(srcList)
	
	for i=1:1:length {
		
		set srcId = $list(srcList, i)
		
		// Получаем список значений аттрибутов по предложениям	
		do ##class(%iKnow.Queries.SourceAPI).GetAttributes(.att, domainId, srcId, 1, 0, "", $$$IKATTLVLSENT)
	    
	    set j = 1
	    
	    // Цикл по списку значений аттрибутов для определения Negation
	    while $data(att(j)) 
	    {
	    	if ($listget(att(j), 1) = 1) {
	        			
				set sentenceId = $listget(att(j),4)
				
				// Получаем ID предложения в таблице (для открытия объекта)
				&sql(SELECT ID INTO :id FROM  iknowAV_Hotels_Processing.Sentence WHERE SentenceId = :sentenceId AND DomainName = :domName)

	           	if (SQLCODE = 0) {
	            	set temp = $list(^iknowAV.Hotels.PrE05F.SentenceD(id), 4)
	            	set $list(^iknowAV.Hotels.PrE05F.SentenceD(id),4) = $list(^iknowAV.Hotels.PrE05F.SentenceD(id),5)
	            	set $list(^iknowAV.Hotels.PrE05F.SentenceD(id),5) = temp
	            	set $list(^iknowAV.Hotels.PrE05F.SentenceD(id),6) = -1
	           	}
	        }
	        
	    	set j = j + 1
	    	
	    }	// while
	}    
	return $$$OK
]]></Implementation>
</Method>

<Method name="ProcessFunctionalMarkers">
<Description>
Метод анализирует предложения указанного источника на функциональные маркеры и заполняет
оценки iKnowRating* в таблиц iknowAV_Hotels_Stat.Review
domName - имя домена
srcId - ID источника
applyNegation - учитывать ли предложения с Negation. 0 - не учитывать, 1 - учитывать</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,srcId:%Integer,applyNegation:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	// Получаем ID домена
	set domainId = ##class(iknowAV.util.main).GetDomainId(domName)	
	
	// Получаем ID отзыва в таблице
	&sql(SELECT ID INTO :id FROM  iknowAV_Hotels_Stat.Review WHERE DomainName = :domName AND SourceId = :srcId)
	
	// Если значение получено, открываем источник по ID
	if (SQLCODE = 0) {	
		set review = ##class(iknowAV.Hotels.Stat.Review).%OpenId(id)	
	}
	else {
		write "Error: source " + srcId + " not found", !
		return $$$ERROR()
	}
	
	// Позитивное и негативное значения в рамках категории
	#dim positive As %Integer = 0
	#dim negative As %Integer = 0
	
	#dim positiveMarkersSum As %Integer = 0
	#dim negativeMarkersSum As %Integer = 0
	
	// Оценка в рамках категории
	#dim grade As %Numeric = 0
	
	// Категория функционального маркера
	#dim markerCategory As %String  = ""
	
	// Счетчик оцененных категорий
	#dim gradedCategoryCount As %Integer = 0
	
	// Общая оценка
	#dim totalGrade As %Numeric = 0
	
	// Позитивное и негативное значения в рамках всего отзыва
	#dim totalNegative As %Integer = 0
	#dim totalPositive As %Integer = 0
	
	set p1 = ""
		
	for
	{	
		set p1 = $order(^fmarkers(p1))
		quit:(p1 = "")
		
		set line = ^fmarkers(p1)
				
		// проверка строки на комментарий (начинается с !)		
		set checkComment = $piece(line,"!",1,1)
		if (checkComment="") { continue }
		
		// Обработка строки
		set stype = $piece(line,"#",1)
		
		if (stype = "d") { continue }
		// Обрабатываем строку с названием категории
		elseif (stype = "i") 
		{
			
			kill grade
			
			// Если у нас есть категория (при первом проходе ее нет), то рассчитываем оценку по этой категории
			if (markerCategory '= "")
			{			
				
				if ((negative = 0) && (positive = 0)) { write "    No grade for Category: ", markerCategory, ! }
				elseif (negative = 0) 				 { set grade = 1 }
				elseif (positive = 0)				 { set grade = 0.2 }
				else 								 { set grade = positive / (positive + negative) }
				
				// Определяем свойство для изменения по категории
				set property = $case(markerCategory, "Comfort":"iKnowRatingComfort", "Food":"iKnowRatingFood", 
									 "Hospitality":"iKnowRatingHospitality", "Location":"iKnowRatingLocation",
									 "Territory":"iKnowRatingTerritory", "Service":"iKnowRatingService")
				
				// Устаналиваем значение соответствующего свойства
				if $data(grade) {	
					// Переводим оценку в вид от 1 до 5 
					set grade = grade * 5
					set $property(review,property) = grade
					set gradedCategoryCount = gradedCategoryCount + 1
					set totalGrade = totalGrade + grade
					
					// Для статистики 
					set positiveMarkersSum = positiveMarkersSum + positive
					set negativeMarkersSum = negativeMarkersSum + negative
					
				}
				else { set $property(review, property) = "" }
				
				// Обнуляем positive и negative (для следующей категории)
				set positive = 0
				set negative = 0
			}
			
			// Получаем название следующей категории
			set markerCategory = $piece(line,"#",2)
			continue
		}
		// Обрабатываем строку с терминами
		elseif ((stype="t") || (stype="s")) 
		{
			// $piece(line,"#",2) - текущий термин
			set entityValue = $piece(line,"#",2)
			set entityId = ##class(%iKnow.Queries.EntityAPI).GetId(domainId, entityValue)	

			kill result
			
			// Получаем список предложений в источнике, содержащих данный концепт					
			set st = ##class(%iKnow.Queries.SentenceAPI).GetByEntityIds(.result, domainId, $lb(entityId), $lb(srcId), 1, 0)			
			
			set p2 = ""
			
			if '($data(result(1))) { continue }
			
			// Цикл по предложениям, содержащим концепт
			for 
			{					
				set p2 = $order(result(p2))	
				quit:(p2 = "")
				
				// ID предложения в sentenceId		
				set sentenceId = $list(result(p2), 3)	
				
				// Получаем ID предложения в таблице (для открытия объекта)
				&sql(SELECT Negation, Negative, Positive 
					 INTO :negation, :sNegative, :sPositive 
					 FROM  iknowAV_Hotels_Processing.Sentence 
					 WHERE SentenceId = :sentenceId AND DomainName = :domName)
				
				// Если SQL-запрос ничего не вернул, то создаем новый объект
				if (SQLCODE = 100) { continue }
				
				// Пропускаем предложения с отрицанием, если указан соответствующий параметр
				if ((applyNegation = 0) && (negation = -1)) { continue } 
						
				// Накапливаем вес в соответствующей категории
				set positive = positive + sPositive
				set negative = negative + sNegative
				set totalNegative = totalNegative + sNegative
				set totalPositive = totalPositive + sPositive
								
			}	// for (Sentence)

		}	// elseif (stype="t") 		
		
	} // while ('stream.AtEnd)
	
	// Если у нас есть хоть одна оцененная отзывом категория, рассчитываем общий рейтинг
	if (gradedCategoryCount > 0) {
		set review.iKnowRating = totalGrade / gradedCategoryCount
		
		// Приводим Emarkers в дискретный вид от 1 до 5
		set review.iKnowEmarkersRating = $SYSTEM.SQL.CEILING($normalize((totalPositive / ( totalPositive + totalNegative)) * 5 - 0.1, -1) + 1)
	}
	
	set hotelId = review.HotelId
	set hotelName = ##class(%iKnow.Queries.MetadataAPI).GetValueById(domainId, 4, srcId)
	
	set numberOfEntities = ##class(%iKnow.Queries.EntityAPI).GetCountBySource(domainId, srcId)
	if (numberOfEntities = 0) { set numberOfEntities = 1 }
	
	set emotionalSum = positiveMarkersSum + negativeMarkersSum
	set numberOfSentences = ##class(%iKnow.Queries.SentenceAPI).GetCountBySource(domainId, srcId)
	
	&sql(INSERT INTO iknowAV_Hotels_Stat.ReviewStat (DomainName, ReviewId, HotelId, HotelName, NumberOfEntities, 
	     EmotionalSum, NumberOfSentences, PositiveMarkersSum, NegativeMarkersSum)
	     VALUES (:domName, :srcId, :hotelId, :hotelName, :numberOfEntities, :emotionalSum, 
	             :numberOfSentences, :positiveMarkersSum, :negativeMarkersSum))
	
	// Сохраняем объект отзыва
	do review.%Save()
	kill review
	
	return $$$OK
]]></Implementation>
</Method>

<Method name="ProcessHotelsGrades">
<Description>
Метод, вычисляющий финальные оценки по отелю</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Получаем список всех отелей
	&sql(SELECT %DLIST(DISTINCT HotelId) INTO :hotelIdList FROM iknowAV_Hotels_Stat.Review)
	
	set length = $listlength(hotelIdList)

	// Цикл по всем отелям
	for i=1:1:length
	{
	
		set hotelId = $list(hotelIdList, i)
		&sql(SELECT HotelName INTO :hotelName FROM iknowAV_Hotels_Stat.ReviewStat WHERE HotelId = :hotelId)
		
		&sql(SELECT AVG(NULLIF(iKnowRating, 0)), AVG(NULLIF(iKnowEmarkersRating,0)), AVG(NULLIF(iKnowRatingComfort,0)), AVG(NULLIF(iKnowRatingFood, 0)),
	            	AVG(NULLIF(iKnowRatingHospitality, 0)), AVG(NULLIF(iKnowRatingLocation,0)), AVG(NULLIF(iKnowRatingService,0)), AVG(NULLIF(iKnowRatingTerritory,0)),
	            	AVG(NULLIF(AuthorRating,0)), AVG(NULLIF(AuthorRatingComfort,0)), AVG(NULLIF(AuthorRatingFood,0)),
	            	AVG(NULLIF(AuthorRatingHospitality,0)), AVG(NULLIF(AuthorRatingLocation,0)), AVG(NULLIF(AuthorRatingService,0)), AVG(NULLIF(AuthorRatingTerritory,0))
        	 INTO :iKnowRating, :iKnowEmarkersRating, :iKnowRatingComfort, :iKnowRatingFood,
		     	  :iKnowRatingHospitality, :iKnowRatingLocation, :iKnowRatingService, :iKnowRatingTerritory,
		     	  :authorRating, :authorRatingComfort, :authorRatingFood,
		     	  :authorRatingHospitality, :authorRatingLocation, :authorRatingService, :authorRatingTerritory
		     FROM iknowAV_Hotels_Stat.Review
		     WHERE HotelId = :hotelId)
		     
		set neutralHighBorder = ..#NEUTRALHIGHBORDER
		set neutralLowBorder = ..#NEUTRALLOWBORDER 
		     
		&sql(SELECT COUNT(ID) INTO :positiveReviews FROM iknowAV_Hotels_Stat.Review WHERE HotelId = :hotelId AND iKnowRating > :neutralHighBorder)
		&sql(SELECT COUNT(ID) INTO :negativeReviews FROM iknowAV_Hotels_Stat.Review WHERE HotelId = :hotelId AND iKnowRating < :neutralLowBorder)
		&sql(SELECT COUNT(ID) INTO :neutralReviews FROM iknowAV_Hotels_Stat.Review WHERE HotelId = :hotelId AND iKnowRating <= :neutralHighBorder AND iKnowRating >= :neutralLowBorder)
		&sql(SELECT COUNT(ID) INTO :numberOfReviews FROM iknowAV_Hotels_Stat.Review WHERE HotelId = :hotelId AND iKnowRating > 0)
		
		set positiveReviewsPCT = 0
		set negativeReviewsPCT = 0
		set neutralReviewsPCT = 0
		
		if (numberOfReviews > 0) {
			set positiveReviewsPCT = positiveReviews / numberOfReviews * 100
			set negativeReviewsPCT = negativeReviews / numberOfReviews * 100
			set neutralReviewsPCT = neutralReviews / numberOfReviews * 100
		}
		
	    // Записываем результаты в таблицу
		&sql(INSERT OR UPDATE INTO iknowAV_Hotels_Stat.Hotel 
			 (HotelId, HotelName, NegativeReviewsPCT, PositiveReviewsPCT, NeutralReviewsPCT,
			  ReviewsCount, UserRating, UserRatingComfort, UserRatingFood, UserRatingHospitality,
			  UserRatingLocation, UserRatingService, UserRatingTerritory, iKnowRating, iKnowEmarkersRating, iKnowRatingComfort,
			  iKnowRatingFood, iKnowRatingHospitality, iKnowRatingLocation, iKnowRatingService,
			  iKnowRatingTerritory)
			 VALUES (:hotelId, :hotelName, :negativeReviewsPCT, :positiveReviewsPCT, :neutralReviewsPCT,
			 		 :numberOfReviews, :authorRating, :authorRatingComfort, :authorRatingFood,
		     	     :authorRatingHospitality, :authorRatingLocation, :authorRatingService, :authorRatingTerritory, 
		     	     :iKnowRating, :iKnowEmarkersRating, :iKnowRatingComfort, :iKnowRatingFood,
		     	     :iKnowRatingHospitality, :iKnowRatingLocation, :iKnowRatingService, :iKnowRatingTerritory))
	}
	
	return $$$OK
]]></Implementation>
</Method>

<Method name="ProcessingStats">
<Description>
Метод, рассчитывающий общую статистику и статистику по отелям (Эмоциональной насыщенности).
domName - имя домена
applyNegation: 1 - учитывать предложения с Negation, 0 - не учитывать.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,applyNegation:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	#dim domId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	
	&sql(INSERT INTO iknowAV_Hotels_Stat.HotelStat (HotelId, HotelName, PositiveMarkersSum, NegativeMarkersSum, EmotionalSum, NumberOfEntities, NumberOfSentences)
	     SELECT HotelId, HotelName, AVG(PositiveMarkersSum), AVG(NegativeMarkersSum), AVG(EmotionalSum), AVG(NumberOfEntities), AVG(NumberOfSentences)
	     FROM iknowAV_Hotels_Stat.ReviewStat
	     GROUP BY HotelId
	)
	
	set processingResult = ##class(iknowAV.Hotels.Stat.ProcessingResult).%New()
	set processingResult.DomainName = domName
	
	// Подсчет строк файла эмоциональных маркеров		
	#dim filename As %String = ^iknowAVDomainFolder(domName)_"emarkers.txt"
	#dim stream As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
	set status = stream.LinkToFile(filename)
	
	set lineCounter = 0
	
	while '(stream.AtEnd) {
		do stream.ReadLine()
		set lineCounter = lineCounter + 1	
	}
	
	set processingResult.EDictionarySize = lineCounter
	
	// Подсчет строк файла функциональных маркеров		
	set filename  = ^iknowAVDomainFolder(domName)_"fmarkers.txt"
	set stream = ##class(%Stream.FileCharacter).%New()
	set status = stream.LinkToFile(filename)
	
	set lineCounter = 0
	
	while '(stream.AtEnd) {
		do stream.ReadLine()
		set lineCounter = lineCounter + 1	
	}	
	
	set processingResult.FDictionarySize = lineCounter
	
	// Получаем среднее значение Эмоциональной Насыщенности по всем отелям
	&sql(SELECT AVG(EmotionalSaturation), AVG(PositiveEmotionalSaturation), AVG(NegativeEmotionalSaturation) 
	     INTO :emotionalSaturation, :positiveEmotionalSaturation, :negativeEmotionalSaturation
	     FROM iknowAV_Hotels_Stat.HotelStat)
	
	set processingResult.EmotionalIndex = emotionalSaturation / processingResult.EDictionarySize * 1000
	set processingResult.PositiveIndex = positiveEmotionalSaturation / processingResult.EDictionarySize * 1000
	set processingResult.NegativeIndex = negativeEmotionalSaturation / processingResult.EDictionarySize * 1000
	
	#dim numOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)
	set processingResult.NumberOfSources = numOfSources	
	set processingResult.Negation = applyNegation	
	set processingResult.ProcessingDateTime = $zdatetime($h,3)
	
	set tSC = processingResult.%Save()
	
	return tSC
]]></Implementation>
</Method>

<Method name="DetectSuspectReviewsByHotel">
<Description>
Метод, расчитывающий оценку подозрительности каждого отзыва.
hotelId - ID отеля (будут обработаны все отзывы этого отеля)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>hotelId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	&sql(SELECT %DLIST(PositiveEmotionalSaturation) INTO :pesList FROM iknowAV_Hotels_Stat.ReviewStat WHERE HotelId = :hotelId)
	
	set stdDev = ##class(iknowAV.Hotels.Stat.Statistics).StdDev(pesList)
	set mean = ##class(iknowAV.Hotels.Stat.Statistics).Mean(pesList)
	
	&sql(SELECT %DLIST(ID) INTO :idList FROM iknowAV_Hotels_Stat.ReviewStat WHERE HotelId = :hotelId)

	set length = $listlength(idList)
	
	for i=1:1:length
	{
		
		 set suspect = 0
		 
	     // Открываем отзыв
	     set reviewStat = ##class(iknowAV.Hotels.Stat.ReviewStat).%OpenId($list(idList, i))	
	     
	     if (reviewStat.EmotionalSaturation = 0) { continue }
		 
		 if ('($data(stdDev)) || (stdDev = 0)) { continue }
	     
	     if (($zabs(reviewStat.PositiveEmotionalSaturation - mean)) > (3 * stdDev)) {
		     set suspect = suspect + 1
	     }
	     
	     
	     if ((reviewStat.PositiveEmotionalSaturation / reviewStat.EmotionalSaturation) > ..#PESSUSPECT) {
		     set suspect = suspect + 1
	     }
	     
	     set reviewId = reviewStat.ReviewId 

		 &sql(UPDATE iknowAV_Hotels_Stat.Review SET Suspect = :suspect WHERE SourceId = :reviewId)

		 kill reviewStat	 
	}
	
	return $$$OK
]]></Implementation>
</Method>

<Method name="CalcReviewsUsefulness">
<Description>
Метод, расчитывающий оценку полезности каждого отзыва.
hotelId - ID отеля (будут обработаны все отзывы этого отеля)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>hotelId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set usefulness = 0
	set us1 = 0
	set us2 = 0
	set us3 = 0
	
	&sql(SELECT %DLIST(EmotionalSaturation), %DLIST(ID) INTO :esList, :idList FROM iknowAV_Hotels_Stat.ReviewStat WHERE HotelId = :hotelId)	
	
	set meanES = ##class(iknowAV.Hotels.Stat.Statistics).Mean(esList)
	set stdevES = ##class(iknowAV.Hotels.Stat.Statistics).StdDev(esList)
	
	set length = $listlength(idList)
	
	for i=1:1:length
	{
	
	     // Открываем отзыв
	     set reviewStat = ##class(iknowAV.Hotels.Stat.ReviewStat).%OpenId($list(idList, i))	
	     
	     if (reviewStat.EmotionalSaturation = 0) { continue }
		
		 if (('$data(stdevES) || (stdevES = 0))) { set us1 = 0 }
		 else 									 { set us1 = 1 - (($zabs(reviewStat.EmotionalSaturation - meanES)) / (3 * stdevES)) }
		 
		 if (us1 < 0) { set us1 = 0 }
		 
	     set reviewId = reviewStat.ReviewId 
		 
 		 &sql(SELECT iKnowRatingFood, iKnowRatingComfort, iKnowRatingService, iKnowRatingHospitality, iKnowRatingLocation, iKnowRatingTerritory
 		 	  INTO :food, :comfort, :service, :hospitality, :location, :territory 
 		 	  FROM iknowAV_Hotels_Stat.Review WHERE SourceId = :reviewId)
		   
		 set us2 = $case(food, "":0, :1) + $case(comfort, "":0, :1) + $case(service, "":0, :1) + $case(hospitality, "":0, :1) + $case(location, "":0, :1) + $case(territory, "":0, :1)
		   
		 set us2 = us2 / 6
		 
		 if (reviewStat.PositiveEmotionalSaturation >= reviewStat.NegativeEmotionalSaturation) {
			 set us3 = 2 * (reviewStat.NegativeEmotionalSaturation / reviewStat.EmotionalSaturation)
		 }
		 else {
			 set us3 = 2 * (reviewStat.PositiveEmotionalSaturation / reviewStat.EmotionalSaturation)
		 }
		 
		 set usefulness = (us1 + us2 + us3) / 3 * 100
		 
		 &sql(UPDATE iknowAV_Hotels_Stat.Review SET Usefulness = :usefulness WHERE SourceId = :reviewId)

		 kill reviewStat	 
	}
	
	return $$$OK
]]></Implementation>
</Method>

<Method name="ClearSentences">
<Description>
Очищает таблицу с предложениями.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	// Очищаем таблицу Sentence
	&sql(DELETE FROM iknowAV_Hotels_Processing.Sentence)
	
	if (SQLCODE < 0) { return $$$ERROR() }
	else 			 { return $$$OK }
]]></Implementation>
</Method>

<Method name="ClearStats">
<Description>
Метод удаления предыдущей статистики по указанному домену.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	&sql(DELETE FROM iknowAV_Hotels_Stat.ReviewStat WHERE DomainName = :domName)
	&sql(DELETE FROM iknowAV_Hotels_Stat.HotelStat)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// ------------------------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ЕЩЕ НЕ ОТЛАЖЕНО И НЕ ДЕБАВЛЕНО В ОСНОВНУЮ ЧАСТЬ КОДА

]]></Content>
</UDLText>

<Method name="GetCategoryDetail">
<Description>
Метод, собирающий в $list ID всех предложений, в которых упоминается самый популярный концепт в 
указанной категории указанного отеля с указанным окрасом (positiveGrade) 
DomName - имя домена
hotelId - ID отеля
categoryName - имя категории
positiveGrade - предложения с каким окрасом выбирать. 1 - позитивные, 0 - негативные.
numberOfWordsInSentence - максимальное количество слов в отдельно взятом предложении</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,hotelId:%Integer,categoryName:%String,positiveGrade:%Boolean,numberOfWordsInSentence:%Integer=15</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Получаем ID домена
	set domainId = ##class(iknowAV.util.main).GetDomainId(domName)	
	// Самая часто встречающаяся сущность (по отзывам)
	set mostSpreadEntity = ""
	// Частота встречаемости (по отзывам)
	set mostSpread = 0
	// Id mostSpreadEntity
	set mostSpreadEntityId = 0
	// Текущая сущность
	set currentEntity = ""
	// Текущая встречаемость
	set currentSpread = 0
	// Текущая категория
	set markerCategory = ""
	//
	set topResult = $lb()
	set allResult = $lb()
	
	// Устанавливаем фильтр по HotelId
	set filter = ##class(%iKnow.Filters.SimpleMetadataFilter).%New(domainId, "HotelId","=",hotelId)
	
	// Загрузка файла со словарем функциональных маркеров		
	#dim filename As %String = ^iknowAVDomainFolder(domName)_"fmarkers.txt"
	//write "   fmarkers file... ", filename,!
	#dim stream As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
	set status = stream.LinkToFile(filename)
	
	set categoryFound = 0
	
	// Цикл по строкам файла	
	while '(stream.AtEnd) 
	{		
		set line = stream.ReadLine()
	
		// проверка строки на комментарий (начинается с !)		
		set checkComment = $piece(line,"!",1,1)
		if (checkComment="") { continue }
		
		// Обработка строки
		set stype = $piece(line,"#",1)
		
		if (stype = "d") { continue }
		// Обрабатываем строку с названием категории
		elseif (stype = "i") 
		{
			// Получаем название следующей категории
			set markerCategory = $piece(line,"#",2)
	
			if (categoryName '= markerCategory) { continue }
			else { set categoryFound = 1 }
		}
		// Обрабатываем строку с терминами
		elseif (stype="t") 
		{
			if (categoryName '= markerCategory) { continue }
			
			// Получаем название следующей категории
			set dList = $piece(line,"#",2)	
			set j = 1
			
			// Цикл по терминам в строке
			while ($piece(dList,",",j)'="")
			{	
				// $piece(dList,",",j) - текущий термин
				set currentEntity = $piece(dList,",",j)
				set j = j + 1
				
				// Для первого прохода
				if (mostSpreadEntity = "") 
				{
					set entityId = ##class(%iKnow.Queries.EntityAPI).GetId(domainId,currentEntity)
	
					if (entityId = "") { continue }			
							
					set mostSpreadEntity = currentEntity
					set mostSpread = ##class(%iKnow.Queries.EntityAPI).GetSpread(domainId,entityId,,filter)
					set mostSpreadEntityId = entityId
				}	
				
				// Ищем Entity с максимальным Spread
				set entityId = ##class(%iKnow.Queries.EntityAPI).GetId(domainId,currentEntity)			
				
				if (entityId = "") { continue }
				
				set currentSpread = ##class(%iKnow.Queries.EntityAPI).GetSpread(domainId,entityId,,filter)	
				
				if (currentSpread > mostSpread) {
					set mostSpread = currentSpread
					set mostSpreadEntity = currentEntity
					set mostSpreadEntityId = entityId
				}		
					
			}
		}
	}
	
	if (categoryFound = 0) { return $$$ERROR("There is no choosen category.") }
	
	write "Category: ", categoryName, !
	write "Most Spread Entity: ", mostSpreadEntity, !
	write "Spread: ", mostSpread, !
	
	kill srcResult
	
	// Получаем все источники (отзывы) одного отеля
	do ##class(%iKnow.Queries.SourceAPI).GetByDomain(.srcResult,domainId,1,0,filter)
	
	// Получаем количество источников
	set numberOfReviews = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domainId,filter)
	
	set reviewCount = 1
	
	while (reviewCount <= numberOfReviews)
	{
		set srcId = $list(srcResult(reviewCount),1)

		// Очищаем таблицу Sentence
		set sc = ##class(iknowAV.Hotels.Processing.Processing).ClearSentences()
		// Заполняем таблицу Sentence с учетов эмоциональных маркеров
		set sc = ##class(iknowAV.Hotels.Processing.Processing).BuildProcessingSentences(domName, srcId)
		// Обрабатываем Negation
		set sc = ##class(iknowAV.Hotels.Processing.Processing).ProcessNegationSentences(domName, srcId)
		
		// Получаем ID отзыва в таблице
		&sql(SELECT ID INTO :id FROM  iknowAV_Hotels_Stat.Review WHERE DomainName = :domName)
		
		// Если значение получено, открываем источник по ID
		if (SQLCODE = 0)
		{	
			set review = ##class(iknowAV.Hotels.Stat.Review).%OpenId(id)	
		}
		else
		{
			write "Error: source " + srcId + " not found", !
			return $$$ERROR()
		}
	
		kill result
					
		set iKnowCategory = "iKnowRating"_categoryName			
								
		if (positiveGrade = 1)
		{
			if ($property(review,iKnowCategory) <= ..#POSNEGBORDER) 
			{ 
				set reviewCount = reviewCount + 1
				continue 
			}
		}		
		else 
		{
			if ($property(review,iKnowCategory) > ..#POSNEGBORDER) { 
				set reviewCount = reviewCount + 1
				continue 
			}			
		}	
						
		// Получаем список предложений в источнике, содержащих данный концепт					
		set st = ##class(%iKnow.Queries.SentenceAPI).GetByEntityIds(.result, domainId, $lb(mostSpreadEntityId), $lb(srcId), 1, 0)					

		set p2 = ""
						
		if '($data(result(1))) { 
			set reviewCount = reviewCount + 1
			continue 
		}
						
		// Цикл по предложениям, содержащим концепт
		for 
		{					
			set p2 = $order(result(p2))	
			quit:(p2 = "")
			
			// ID предложения в sentenceId		
			set sentenceId = $list(result(p2), 3)	
			
			// Получаем ID предложения в таблице (для открытия объекта)
			&sql(SELECT ID INTO :id FROM  iknowAV_Hotels_Processing.Sentence WHERE SentenceId = :sentenceId AND DomainName = :domName)
			
			// Если SQL-запрос ничего не вернул, то берем следующее предложение
			if (SQLCODE = 100) { continue }
			// Если SQL-запрос вернул нам ID, то открываем объект
			elseif (SQLCODE = 0) {
				set sentence = ##class(iknowAV.Hotels.Processing.Sentence).%OpenId(id)
			}

			if (sentence.Negation = -1) { continue } 
			
			set currentSentence = ##class(%iKnow.Queries.SentenceAPI).GetValue(domainId, sentenceId)

			set sentenceLength = $length(currentSentence, " ")
			
			if (sentenceLength < numberOfWordsInSentence)
			{
				set $list(allResult,*+1) = sentenceId
			}
								
		 }	// for (Sentence)

			
		set reviewCount = reviewCount + 1 
	}
	
	set $list(allResult, 1) = $listlength(allResult) - 1	
		
	&sql(SELECT id INTO :hotelObjId FROM iknowAV_Hotels_Stat.Hotel WHERE HotelId = :hotelId)
	
	// Если SQL-запрос ничего не вернул
	if (SQLCODE = 100) { return $$$ERROR() }
	// Если SQL-запрос вернул нам ID, то открываем объект
	elseif (SQLCODE = 0)
	{
		set hotel = ##class(iknowAV.Hotels.Stat.Hotel).%OpenId(hotelObjId)
	}		
	
	set property = "Sent"_categoryName
	
	set $property(hotel,property) = allResult
	do hotel.%Save()
	kill hotel
	
	return $$$OK
]]></Implementation>
</Method>

<Method name="ProcessAllHotelsSents">
<Description>
Метод выборки предложений по всем категориям всех отелей
domName - имя домена </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
		&sql(SELECT %DLIST(HotelId), %DLIST(id) INTO :hotelIdList, :idList FROM iknowAV_Hotels_Stat.Hotel)
		
		set length = $listlength(hotelIdList)
		
		for i=1:1:length
		{
		
			for categoryName = "Comfort","Food","Hospitality","Location","Service","Territory" 
			{
				
				set hotel = ##class(iknowAV.Hotels.Stat.Hotel).%OpenId($list(idList,i))
				set property = "iKnowRating"_categoryName
				
				if ($property(hotel, property) > 3) { set positiveGrade = 1 }
				else { set positiveGrade = 0 }
				
				kill hotel
				
				do ..GetCategoryDetail(domName, $list(hotelIdList,i), categoryName, positiveGrade)
			}	
		}
		
		return $$$OK
]]></Implementation>
</Method>

<Method name="GetRandomSentences">
<Description>
Метод, возвращающий случайные предложения по указанной категории в указанном отеле
domName - имя домена
hotelId - ID отеля
categoryName - название категории
numberOfResults - количество результатов (на данный момент не используется и возвращается только 1 случайный)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,hotelId:%Integer,categoryName:%String,numberOfResults:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	&sql(SELECT id INTO :hotelObjId FROM iknowAV_Hotels_Stat.Hotel WHERE HotelId = :hotelId)
	
	// Если SQL-запрос ничего не вернул
	if (SQLCODE = 100) { return "" }
	// Если SQL-запрос вернул нам ID, то открываем объект
	elseif (SQLCODE = 0)
	{
		set hotel = ##class(iknowAV.Hotels.Stat.Hotel).%OpenId(hotelObjId)
	}		
	
	set property = "Sent"_categoryName
	
	set allResult = $property(hotel,property)
	kill hotel
	
	set count = 0
	
	set alreadyInResultList = $lb()
	
	while ((count <= numberOfResults) && (count < ($list(allResult, 1))))
	{
		// Получаем ID домена	
		set domainId = ##class(iknowAV.util.main).GetDomainId(domName)	
		
		// Первый элемент у нас содержит количество предложений в листе, а random дает от 0 до n. Поэтому прибавляем 2.
		set rnd = $random($list(allResult, 1)) + 2
	
		if ($listfind(alreadyInResultList, rnd) '= 0) { continue }
		
		set $list(topResult,*+1) = $list(allResult, rnd)
		set $list(alreadyInResultList,*+1) = rnd
		
		set count = count + 1
	}
	
	set $list(topResult, 1) = $listlength(topResult) - 1
	
	// return topResult
	return ##class(%iKnow.Queries.SentenceAPI).GetValue(domainId, $list(topResult,2))
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ------------------------------------------------------------------------------------------------------------

]]></Content>
</UDLText>
</Class>


<Class name="iknowAV.Hotels.Processing.Sentence">
<Super>%Persistent</Super>
<TimeChanged>63416,34094.441841</TimeChanged>
<TimeCreated>63382,57101.968597</TimeCreated>

<Property name="SentenceId">
<Description>
ID предложения.</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="SentenceIdIndex">
<Properties>SentenceId</Properties>
<Unique>1</Unique>
</Index>

<Property name="DomainName">
<Description>
Имя домена, в котором содержится источник.</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="Positive">
<Description>
Количество позитивных маркеров.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Negative">
<Description>
Количество негативных маркеров.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Negation">
<Description>
Флаг отрицания</Description>
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^iknowAV.Hotels.PrE05F.SentenceD</DataLocation>
<DefaultData>SentenceDefaultData</DefaultData>
<IdLocation>^iknowAV.Hotels.PrE05F.SentenceD</IdLocation>
<IndexLocation>^iknowAV.Hotels.PrE05F.SentenceI</IndexLocation>
<StreamLocation>^iknowAV.Hotels.PrE05F.SentenceS</StreamLocation>
<Data name="SentenceDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>SentenceId</Value>
</Value>
<Value name="3">
<Value>DomainName</Value>
</Value>
<Value name="4">
<Value>Positive</Value>
</Value>
<Value name="5">
<Value>Negative</Value>
</Value>
<Value name="6">
<Value>Negation</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="iknowAV.Hotels.Stat.Hotel">
<Super>%Persistent,%XML.Adaptor</Super>
<TimeChanged>63399,59138.315946</TimeChanged>
<TimeCreated>63382,56812.800158</TimeCreated>

<Property name="HotelId">
<Description>
ID отеля.</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="HotelIdIndex">
<Properties>HotelId</Properties>
<Unique>1</Unique>
</Index>

<Property name="HotelName">
<Description>
Название отеля.</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="UserRating">
<Description>
Авторская оценка отеля</Description>
<Type>%Numeric</Type>
</Property>

<Property name="UserRatingComfort">
<Description>
Авторская оценка комфортабельности</Description>
<Type>%Numeric</Type>
</Property>

<Property name="UserRatingLocation">
<Description>
Авторская оценка месторасположения</Description>
<Type>%Numeric</Type>
</Property>

<Property name="UserRatingService">
<Description>
Авторская оценка сервиса</Description>
<Type>%Numeric</Type>
</Property>

<Property name="UserRatingFood">
<Description>
Авторская оценка пищи</Description>
<Type>%Numeric</Type>
</Property>

<Property name="UserRatingTerritory">
<Description>
Авторская оценка территории</Description>
<Type>%Numeric</Type>
</Property>

<Property name="UserRatingHospitality">
<Description>
Авторская оценка гостепреимности</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRating">
<Description>
Рассчитанная оценка отеля</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowEmarkersRating">
<Description>
Рассчитанная оценка домена без учета функциональных маркеров</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingComfort">
<Description>
Рассчитанная оценка комфортабельности</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingLocation">
<Description>
Рассчитанная оценка месторасположения</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingService">
<Description>
Рассчитанная оценка сервиса</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingFood">
<Description>
Рассчитанная оценка пищи</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingTerritory">
<Description>
Рассчитанная оценка территории</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingHospitality">
<Description>
Рассчитанная оценка гостепреимсности</Description>
<Type>%Numeric</Type>
</Property>

<Property name="ReviewsCount">
<Description>
Количество отзывов</Description>
<Type>%Integer</Type>
</Property>

<Property name="NegativeReviewsPCT">
<Description>
Процент негативных отзывов</Description>
<Type>%Numeric</Type>
</Property>

<Property name="PositiveReviewsPCT">
<Description>
Процент позитивных отзывов</Description>
<Type>%Numeric</Type>
</Property>

<Property name="NeutralReviewsPCT">
<Description>
Процент ненейтральных отзывов</Description>
<Type>%Numeric</Type>
</Property>

<Property name="SentComfort">
<Description>
Список предложений из отзывов, характеризующих комфортабельность отеля.</Description>
<Type>%List</Type>
</Property>

<Property name="SentFood">
<Description>
Список предложений из отзывов, характеризующих питание в отеле.</Description>
<Type>%List</Type>
</Property>

<Property name="SentHospitality">
<Description>
Список предложений из отзывов, характеризующих гостеприимство отеля.</Description>
<Type>%List</Type>
</Property>

<Property name="SentLocation">
<Description>
Список предложений из отзывов, характеризующих месторасположение отеля.</Description>
<Type>%List</Type>
</Property>

<Property name="SentService">
<Description>
Список предложений из отзывов, характеризующих уровень сервиса в отеле.</Description>
<Type>%List</Type>
</Property>

<Property name="SentTerritory">
<Description>
Список предложений из отзывов, характеризующих территорию отеля.</Description>
<Type>%List</Type>
</Property>

<Method name="GetFinalText">
<Description>
Метод получения финальной фразы по отелю
hotelId - ID отеля</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>hotelId:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set reviewCount = 0
	set iKnowRatingPositive = 0
	set iKnowRatingComfortPositive = 0
	set iKnowRatingFoodPositive = 0
	set iKnowRatingHospitalityPositive = 0
	set iKnowRatingLocationPositive = 0
	set iKnowRatingServicePositive = 0
	set iKnowRatingTerritoryPositive = 0
	set iKnowRatingNegative = 0
	set iKnowRatingComfortNegative = 0
	set iKnowRatingFoodNegative = 0
	set iKnowRatingHospitalityNegative = 0
	set iKnowRatingLocationNegative = 0
	set iKnowRatingServiceNegative = 0
	set iKnowRatingTerritoryNegative = 0
	set comfortText = ""
	set hospitalityText = ""
	set foodText = ""
	set serviceText = ""
	set extraText = ""
	
	// Получаем курсор SQL-запросом
	&sql(DECLARE crsr CURSOR FOR
	     SELECT id, iKnowRating, iKnowEmarkersRating, iKnowRatingComfort, iKnowRatingFood,
	            iKnowRatingHospitality, iKnowRatingLocation, iKnowRatingService, iKnowRatingTerritory 
	     INTO :id, :iKnowRating, :iKnowEmarkersRating, :iKnowRatingComfort, :iKnowRatingFood,
	     	  :iKnowRatingHospitality, :iKnowRatingLocation, :iKnowRatingService, :iKnowRatingTerritory
	     FROM iknowAV_Hotels_Stat.Review
	     WHERE HotelId = :hotelId
	)	
	
	// Открываем курсор 
	&sql(open crsr)
	&sql(fetch crsr)
	
	// Идем по курсору. Если оценка по категории > 3 - она позитивная, иначе негативная
	while (SQLCODE '= 100)
	{
		set reviewCount = reviewCount + 1
		
		if (iKnowRating > 3) { set iKnowRatingPositive = iKnowRatingPositive + 1}
		elseif (iKnowRating '= "") { set iKnowRatingNegative = iKnowRatingNegative + 1 }
		
		if (iKnowRatingComfort > 3) { set iKnowRatingComfortPositive = iKnowRatingComfortPositive + 1}
		elseif (iKnowRatingComfort '= "") { set iKnowRatingComfortNegative = iKnowRatingComfortNegative + 1}
		
		if (iKnowRatingFood > 3) { set iKnowRatingFoodPositive = iKnowRatingFoodPositive + 1 }
		elseif (iKnowRatingFood '= "") { set iKnowRatingFoodNegative = iKnowRatingFoodNegative + 1 }
		
		if (iKnowRatingHospitality > 3) { set iKnowRatingHospitalityPositive = iKnowRatingHospitalityPositive + 1 }
		elseif (iKnowRatingHospitality '= "") { set iKnowRatingHospitalityNegative = iKnowRatingHospitalityNegative + 1 }
		
		if (iKnowRatingLocation > 3) { set iKnowRatingLocationPositive = iKnowRatingLocationPositive + 1 }
		elseif (iKnowRatingLocation '= "") { set iKnowRatingLocationNegative = iKnowRatingLocationNegative + 1 }
		
		if (iKnowRatingService > 3) { set iKnowRatingServicePositive = iKnowRatingServicePositive + 1 }
		elseif (iKnowRatingService '= "") { set iKnowRatingServiceNegative = iKnowRatingServiceNegative + 1}
		
		if (iKnowRatingTerritory > 3) { set iKnowRatingTerritoryPositive = iKnowRatingTerritoryPositive + 1 }
		elseif (iKnowRatingTerritory '= "") { set iKnowRatingTerritoryNegative = iKnowRatingTerritoryNegative + 1 }
		
		&sql(fetch crsr)
	}
	
	// Получаем название отеля
	&sql(SELECT HotelName INTO :hotelName FROM iknowAV_Hotels_Stat.Hotel WHERE HotelId = :hotelId)
	
	// Получаем обращение, в зависимости от числа
	set lastChar = $extract(reviewCount,*-0)
	set word = $case(lastChar, "1":"человека", :"человек")
	
	set finalText = "Из "_reviewCount_" "_word_", отдыхавших в отеле "_hotelName_", " 
	
	set var = $random(6) + 1
	
	if (iKnowRatingPositive > iKnowRatingNegative) 
	{
		set hotelText = $case(var,
							  1:"довольны отелем остались ",
							  2:"отель в целом понравился ",
							  3:"отель пришелся по душе ",
							  4:"отель оценили положительно ",
							  5:"посчитали отель хорошим ",
							  6:"остались довольны отелем ")
		
		set hotelText = hotelText_" - "_iKnowRatingPositive_" ("_$NORMALIZE((iKnowRatingPositive / reviewCount * 100), 0)_"%)"					  
							  
	}
	else 
	{
		set hotelText = $case(var,
							  1:"недовольны отелем остались ",
							  2:"отель в целом не понравился ",
							  3:"отель оставил негативное впечатление у ",
							  4:"отель оценили отрицательно ",
							  5:"посчитали отель неудовлетворительным ",
							  6:"остались недовольны отелем ")
							  
		set hotelText = hotelText_" - "_iKnowRatingNegative_" ("_$NORMALIZE((iKnowRatingNegative / reviewCount * 100), 0)_"%)"								  
	}
	
	set finalText = finalText_hotelText_", "	
	
	set var = $random(6) + 1
	
	if (((iKnowRatingComfortPositive + iKnowRatingComfortNegative)/ reviewCount) > 0)
	{
	
		if (iKnowRatingComfortPositive > iKnowRatingComfortNegative) 
		{
			set comfortText = $case(var,
								  1:"условия посчитали комфортными ",
								  2:"понравились условия ",
								  3:"в отеле чувствовали себя комфортно ",
								  4:"комфортабельность оценили положительно ",
								  5:"остались довольны условиями ",
								  6:"посчитали условия комфортными ")
			
			set comfortText = comfortText_"- "_iKnowRatingComfortPositive_" ("_$NORMALIZE((iKnowRatingComfortPositive / (iKnowRatingComfortPositive + iKnowRatingComfortNegative) * 100), 0)_"%*), "					  
								  
		}
		else 
		{
			set comfortText = $case(var,
								  1:"не понравились условия ",
								  2:"условия посчитали некомфортными ",
								  3:"в отеле чувствували себя некомфортно ",
								  4:"комфортабельность оценили отрицательно ",
								  5:"остались недовольны условиями ",
								  6:"посчитали условия некомфортными ")
								  
			set comfortText = comfortText_"- "_iKnowRatingComfortNegative_" ("_$NORMALIZE((iKnowRatingComfortNegative / (iKnowRatingComfortPositive + iKnowRatingComfortNegative) * 100), 0)_"%*), "								  
		}	
	}
	
	set var = $random(6) + 1
	
	if (((iKnowRatingFoodPositive + iKnowRatingFoodNegative)/ reviewCount) > 0)
	{
		if (iKnowRatingFoodPositive > iKnowRatingFoodNegative) 
		{
			set foodText = $case(var,
								  1:"понравилась еда и питание",
								  2:"понравилась еда в ресторанах",
								  3:"положительно оценили качество пищи",
								  4:"остались довольны качеством еды",
								  5:"понравилось питание",
								  6:"высоко оценили качество пищи")
			
			set foodText = iKnowRatingFoodPositive_" ("_$NORMALIZE((iKnowRatingFoodPositive / (iKnowRatingFoodPositive + iKnowRatingFoodNegative) * 100), 0)_"%*) "_foodText_", "					  
								  
		}
		else 
		{
			set foodText = $case(var,
								  1:"не понравилась еда и питание",
								  2:"не понравилась еда в ресторанах",
								  3:"отрицательно оценили качество пищи",
								  4:"остались недовольны качеством еды",
								  5:"не понравилось питание",
								  6:"низко оценили качество пищи")
								  
			set foodText = iKnowRatingFoodNegative_" ("_$NORMALIZE((iKnowRatingFoodNegative / (iKnowRatingFoodPositive + iKnowRatingFoodNegative) * 100), 0)_"%*) "_foodText_", "								  
		}	
	}
	
	set var = $random(6) + 1
	
	if (((iKnowRatingHospitalityPositive + iKnowRatingHospitalityNegative)/ reviewCount) > 0)
	{
		if (iKnowRatingHospitalityPositive > iKnowRatingHospitalityNegative) 
		{
			set hospitalityText = $case(var,
								  1:"отметили вежливость и приветливость персонала",
								  2:"понравилось отношение персонала",
								  3:"отметили гостеприимность персонала отеля",
								  4:"остались довольны работой персонала",
								  5:"высоко оценили уровень работы перонала",
								  6:"понравилось отношение персонала отеля")
			
			set hospitalityText = hospitalityText_" - "_iKnowRatingHospitalityPositive_" ("_$NORMALIZE((iKnowRatingHospitalityPositive / (iKnowRatingHospitalityPositive + iKnowRatingHospitalityNegative) * 100), 0)_"%*), "					  
								  
		}
		else 
		{
			set hospitalityText = $case(var,
								  1:"отметили плохое отношение персонала",
								  2:"не порнавилось отношение персонала",
								  3:"отметили негостеприимность персонала",
								  4:"остались недовольны работой персонала",
								  5:"низко оценили уровень работы персонала",
								  6:"не понравилось отношение персонала отеля")
								  
			set hospitalityText = hospitalityText_" - "_iKnowRatingHospitalityNegative_" ("_$NORMALIZE((iKnowRatingHospitalityNegative / (iKnowRatingHospitalityPositive + iKnowRatingHospitalityNegative) * 100), 0)_"%*), "								  
		}	
	}
	
	set var = $random(6) + 1
	
	if (((iKnowRatingServicePositive + iKnowRatingServiceNegative)/ reviewCount) > 0)
	{
		if (iKnowRatingServicePositive > iKnowRatingServiceNegative) 
		{
			set serviceText = $case(var,
								  1:"понравилось рзнообразие и качество услуг",
								  2:"отметили высокий уровень сервиса",
								  3:"остались довольны качеством услуг",
								  4:"высоко оценили качество предоставляемых услуг",
								  5:"высоко оценили уровень сервиса",
								  6:"положительно оценили качество сервиса")
			
			set serviceText = serviceText_" - "_iKnowRatingServicePositive_" ("_$NORMALIZE((iKnowRatingServicePositive / (iKnowRatingServicePositive + iKnowRatingServiceNegative) * 100), 0)_"%*)"					  
								  
		}
		else 
		{
			set serviceText = $case(var,
								  1:"не понравилось рзнообразие и качество услуг",
								  2:"отметили невысокий уровень сервиса",
								  3:"остались недовольны качеством услуг",
								  4:"низко оценили качество предоставляемых услуг",
								  5:"низко оценили уровень сервиса",
								  6:"отрицательно оценили качество сервиса")
								  
			set serviceText = serviceText_" - "_iKnowRatingServiceNegative_" ("_$NORMALIZE((iKnowRatingServiceNegative / (iKnowRatingServicePositive + iKnowRatingServiceNegative) * 100), 0)_"%*)"								  
		}	
	}	
	
	set var = $random(2) + 1
	
	set extraText = $case(var, 1:" А красивых рыбок никто не оценил, потому что мы о них не спрашивали.",
							   2:" Не забудьте перед поездкой запастись кремом для загара.")
							   
	set var = $random(5) + 1	
	
	if (var '= 1) { set extraText = ""}
	
	set finalText = finalText_comfortText_foodText_hospitalityText_serviceText_"."_extraText
	
	&sql(close crsr)
	
	return finalText
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^iknowAV.Hotels.Stat.HotelD</DataLocation>
<DefaultData>HotelDefaultData</DefaultData>
<IdLocation>^iknowAV.Hotels.Stat.HotelD</IdLocation>
<IndexLocation>^iknowAV.Hotels.Stat.HotelI</IndexLocation>
<StreamLocation>^iknowAV.Hotels.Stat.HotelS</StreamLocation>
<Data name="HotelDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>HotelId</Value>
</Value>
<Value name="3">
<Value>HotelName</Value>
</Value>
<Value name="4">
<Value>UserRating</Value>
</Value>
<Value name="5">
<Value>UserRatingComfort</Value>
</Value>
<Value name="6">
<Value>UserRatingLocation</Value>
</Value>
<Value name="7">
<Value>UserRatingService</Value>
</Value>
<Value name="8">
<Value>UserRatingFood</Value>
</Value>
<Value name="9">
<Value>UserRatingTerritory</Value>
</Value>
<Value name="10">
<Value>UserRatingHospitality</Value>
</Value>
<Value name="11">
<Value>iKnowRating</Value>
</Value>
<Value name="12">
<Value>iKnowEmarkersRating</Value>
</Value>
<Value name="13">
<Value>iKnowRatingComfort</Value>
</Value>
<Value name="14">
<Value>iKnowRatingLocation</Value>
</Value>
<Value name="15">
<Value>iKnowRatingService</Value>
</Value>
<Value name="16">
<Value>iKnowRatingFood</Value>
</Value>
<Value name="17">
<Value>iKnowRatingTerritory</Value>
</Value>
<Value name="18">
<Value>iKnowRatingHospitality</Value>
</Value>
<Value name="19">
<Value>ReviewsCount</Value>
</Value>
<Value name="20">
<Value>NegativeReviewsPCT</Value>
</Value>
<Value name="21">
<Value>PositiveReviewsPCT</Value>
</Value>
<Value name="22">
<Value>NeutralReviewsPCT</Value>
</Value>
<Value name="23">
<Value>SentComfort</Value>
</Value>
<Value name="24">
<Value>SentFood</Value>
</Value>
<Value name="25">
<Value>SentHospitality</Value>
</Value>
<Value name="26">
<Value>SentLocation</Value>
</Value>
<Value name="27">
<Value>SentService</Value>
</Value>
<Value name="28">
<Value>SentTerritory</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="iknowAV.Hotels.Stat.HotelStat">
<Super>%Persistent</Super>
<TimeChanged>63391,53508.99375</TimeChanged>
<TimeCreated>63389,67672.250289</TimeCreated>

<Property name="HotelId">
<Description>
ID отеля</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="hotelIdIndex">
<Properties>HotelId</Properties>
<Unique>1</Unique>
</Index>

<Property name="HotelName">
<Description>
Название отеля.</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="PositiveMarkersSum">
<Description>
Сумма позитивных маркеров в отзыве.</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NegativeMarkersSum">
<Description>
Сумма негативных маркеров в отзыве.</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="EmotionalSum">
<Description>
Общая сумма всех эмоциональных маркеров.</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NumberOfSentences">
<Description>
Количество предложений в отзыве</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NumberOfEntities">
<Description>
Количество сущностей в отзыве.</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="EmotionalSaturation">
<Description>
Эмоциональная насыщенность отзыва.</Description>
<Type>%Numeric</Type>
<Calculated>1</Calculated>
<InitialExpression>0</InitialExpression>
<SqlComputeCode>set {EmotionalSaturation} = {EmotionalSum} / {NumberOfEntities}</SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Property name="PositiveEmotionalSaturation">
<Description>
Позитивная эмоциональная насыщенность отзыва.</Description>
<Type>%Numeric</Type>
<Calculated>1</Calculated>
<InitialExpression>0</InitialExpression>
<SqlComputeCode>set {PositiveEmotionalSaturation} = {PositiveMarkersSum} / {NumberOfEntities}</SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Property name="NegativeEmotionalSaturation">
<Description>
Негативная эмоциональная насыщенность отзыва.</Description>
<Type>%Numeric</Type>
<Calculated>1</Calculated>
<InitialExpression>0</InitialExpression>
<SqlComputeCode>set {NegativeEmotionalSaturation} = {NegativeMarkersSum} / {NumberOfEntities}</SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^iknowAV.Hotels.Stat.HotelStatD</DataLocation>
<DefaultData>HotelStatDefaultData</DefaultData>
<IdLocation>^iknowAV.Hotels.Stat.HotelStatD</IdLocation>
<IndexLocation>^iknowAV.Hotels.Stat.HotelStatI</IndexLocation>
<StreamLocation>^iknowAV.Hotels.Stat.HotelStatS</StreamLocation>
<Data name="HotelStatDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>HotelId</Value>
</Value>
<Value name="3">
<Value>HotelName</Value>
</Value>
<Value name="4">
<Value>PositiveMarkersSum</Value>
</Value>
<Value name="5">
<Value>NegativeMarkersSum</Value>
</Value>
<Value name="6">
<Value>EmotionalSum</Value>
</Value>
<Value name="7">
<Value>NumberOfSentences</Value>
</Value>
<Value name="8">
<Value>NumberOfEntities</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="iknowAV.Hotels.Stat.ProcessingResult">
<Super>%Persistent</Super>
<TimeChanged>63391,53508.961104</TimeChanged>
<TimeCreated>63389,70281.963334</TimeCreated>

<Property name="DomainName">
<Description>
Имя домена</Description>
<Type>%String</Type>
</Property>

<Property name="EDictionarySize">
<Description>
Размер словаря эмоциональных маркеров</Description>
<Type>%Integer</Type>
</Property>

<Property name="FDictionarySize">
<Description>
Размер словаря функциональных маркеров</Description>
<Type>%Integer</Type>
</Property>

<Property name="EmotionalIndex">
<Description>
Эмоциональный индекс (Отношениие Средней Насыщенности Отзывов к размеру словаря)</Description>
<Type>%Numeric</Type>
</Property>

<Property name="PositiveIndex">
<Description>
Положительный эмоциональный индекс</Description>
<Type>%Numeric</Type>
</Property>

<Property name="NegativeIndex">
<Description>
Отрицательный эмоциональный индекс</Description>
<Type>%Numeric</Type>
</Property>

<Property name="NumberOfSources">
<Description>
Количество отзывов</Description>
<Type>%Integer</Type>
</Property>

<Property name="Negation">
<Description>
Флаг Negation (учитывались ли предложения с NEGATION)</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ProcessingDateTime">
<Description>
Время окончания обработки</Description>
<Type>%TimeStamp</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^iknowAV.Ho4531.ProcessingRCBCAD</DataLocation>
<DefaultData>ProcessingResultDefaultData</DefaultData>
<IdLocation>^iknowAV.Ho4531.ProcessingRCBCAD</IdLocation>
<IndexLocation>^iknowAV.Ho4531.ProcessingRCBCAI</IndexLocation>
<StreamLocation>^iknowAV.Ho4531.ProcessingRCBCAS</StreamLocation>
<Data name="ProcessingResultDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>DomainName</Value>
</Value>
<Value name="3">
<Value>EDictionarySize</Value>
</Value>
<Value name="4">
<Value>FDictionarySize</Value>
</Value>
<Value name="5">
<Value>EmotionalIndex</Value>
</Value>
<Value name="6">
<Value>PositiveIndex</Value>
</Value>
<Value name="7">
<Value>NegativeIndex</Value>
</Value>
<Value name="8">
<Value>NumberOfSources</Value>
</Value>
<Value name="9">
<Value>Negation</Value>
</Value>
<Value name="10">
<Value>ProcessingDateTime</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="iknowAV.Hotels.Stat.Review">
<Super>%Persistent</Super>
<TimeChanged>63393,52819.18196</TimeChanged>
<TimeCreated>63378,59046.196236</TimeCreated>

<Property name="DomainName">
<Description>
Имя домена, в котором находится отзыв</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="SourceId">
<Description>
ID отзыва</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="PrimaryKey">
<PrimaryKey>1</PrimaryKey>
<Properties>DomainName,SourceId</Properties>
<Unique>1</Unique>
</Index>

<Property name="AuthorRating">
<Description>
Авторская оценка отеля</Description>
<Type>%Numeric</Type>
</Property>

<Property name="AuthorRatingComfort">
<Description>
Авторская оценка комфортабельности</Description>
<Type>%Numeric</Type>
</Property>

<Property name="AuthorRatingLocation">
<Description>
Авторская оценка месторасположения</Description>
<Type>%Numeric</Type>
</Property>

<Property name="AuthorRatingService">
<Description>
Авторская оценка сервиса</Description>
<Type>%Numeric</Type>
</Property>

<Property name="AuthorRatingFood">
<Description>
Авторская оценка пищи</Description>
<Type>%Numeric</Type>
</Property>

<Property name="AuthorRatingTerritory">
<Description>
Авторская оценка территории</Description>
<Type>%Numeric</Type>
</Property>

<Property name="AuthorRatingHospitality">
<Description>
Авторская оценка гостеприимности</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRating">
<Description>
Рассчитанная оценка отеля</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowEmarkersRating">
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingComfort">
<Description>
Рассчитанная оценка комфортабельности</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingLocation">
<Description>
Рассчитанная оценка месторасположения</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingService">
<Description>
Рассчитанная оценка сервиса</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingFood">
<Description>
Рассчитанная оценка пищи</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingTerritory">
<Description>
Рассчитанная оценка территории</Description>
<Type>%Numeric</Type>
</Property>

<Property name="iKnowRatingHospitality">
<Description>
Рассчитанная оценка гостеприимности</Description>
<Type>%Numeric</Type>
</Property>

<Property name="HotelId">
<Type>%Integer</Type>
</Property>

<Property name="Suspect">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Usefulness">
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^iknowAV.Hotels.Stat.ReviewD</DataLocation>
<DefaultData>ReviewDefaultData</DefaultData>
<IdLocation>^iknowAV.Hotels.Stat.ReviewD</IdLocation>
<IndexLocation>^iknowAV.Hotels.Stat.ReviewI</IndexLocation>
<StreamLocation>^iknowAV.Hotels.Stat.ReviewS</StreamLocation>
<Data name="ReviewDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>DomainName</Value>
</Value>
<Value name="3">
<Value>SourceId</Value>
</Value>
<Value name="4">
<Value>AuthorRating</Value>
</Value>
<Value name="5">
<Value>AuthorRatingComfort</Value>
</Value>
<Value name="6">
<Value>AuthorRatingLocation</Value>
</Value>
<Value name="7">
<Value>AuthorRatingService</Value>
</Value>
<Value name="8">
<Value>AuthorRatingFood</Value>
</Value>
<Value name="9">
<Value>AuthorRatingTerritory</Value>
</Value>
<Value name="10">
<Value>AuthorRatingHospitality</Value>
</Value>
<Value name="11">
<Value>iKnowRating</Value>
</Value>
<Value name="12">
<Value>iKnowEmarkersRating</Value>
</Value>
<Value name="13">
<Value>iKnowRatingComfort</Value>
</Value>
<Value name="14">
<Value>iKnowRatingLocation</Value>
</Value>
<Value name="15">
<Value>iKnowRatingService</Value>
</Value>
<Value name="16">
<Value>iKnowRatingFood</Value>
</Value>
<Value name="17">
<Value>iKnowRatingTerritory</Value>
</Value>
<Value name="18">
<Value>iKnowRatingHospitality</Value>
</Value>
<Value name="19">
<Value>HotelId</Value>
</Value>
<Value name="20">
<Value>Suspect</Value>
</Value>
<Value name="21">
<Value>Usefullness</Value>
</Value>
<Value name="22">
<Value>Usefulness</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="iknowAV.Hotels.Stat.ReviewStat">
<Super>%Persistent</Super>
<TimeChanged>63391,53509.264065</TimeChanged>
<TimeCreated>63389,61279.232043</TimeCreated>

<Property name="ReviewId">
<Description>
ID отзыва (Совпадает с Source ID) </Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Index name="ReviewIdIndex">
<Properties>ReviewId</Properties>
<Unique>1</Unique>
</Index>

<Property name="DomainName">
<Description>
Название домена.</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="HotelId">
<Description>
ID отеля.</Description>
<Type>%Integer</Type>
<Required>1</Required>
</Property>

<Property name="HotelName">
<Description>
Имя отеля</Description>
<Type>%String</Type>
</Property>

<Property name="PositiveMarkersSum">
<Description>
Сумма позитивных маркеров в отзыве.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NegativeMarkersSum">
<Description>
Сумма негативных маркеров в отзыве.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="EmotionalSum">
<Description>
Общая сумма всех эмоциональных маркеров.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NumberOfSentences">
<Description>
Количество предложений в отзыве</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="NumberOfEntities">
<Description>
Количество сущностей в отзыве.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="EmotionalSaturation">
<Description>
Эмоциональная насыщенность отзыва.</Description>
<Type>%Numeric</Type>
<Calculated>1</Calculated>
<InitialExpression>0</InitialExpression>
<SqlComputeCode>set {EmotionalSaturation} = {EmotionalSum} / {NumberOfEntities}</SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Property name="PositiveEmotionalSaturation">
<Description>
Позитивная эмоциональная насыщенность отзыва.</Description>
<Type>%Numeric</Type>
<Calculated>1</Calculated>
<InitialExpression>0</InitialExpression>
<SqlComputeCode>set {PositiveEmotionalSaturation} = {PositiveMarkersSum} / {NumberOfEntities}</SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Property name="NegativeEmotionalSaturation">
<Description>
Негативная эмоциональная насыщенность отзыва.</Description>
<Type>%Numeric</Type>
<Calculated>1</Calculated>
<InitialExpression>0</InitialExpression>
<SqlComputeCode>set {NegativeEmotionalSaturation} = {NegativeMarkersSum} / {NumberOfEntities}</SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^iknowAV.Hotels4531.ReviewStatD</DataLocation>
<DefaultData>ReviewStatDefaultData</DefaultData>
<IdLocation>^iknowAV.Hotels4531.ReviewStatD</IdLocation>
<IndexLocation>^iknowAV.Hotels4531.ReviewStatI</IndexLocation>
<StreamLocation>^iknowAV.Hotels4531.ReviewStatS</StreamLocation>
<Data name="ReviewStatDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ReviewId</Value>
</Value>
<Value name="3">
<Value>DomainName</Value>
</Value>
<Value name="4">
<Value>HotelId</Value>
</Value>
<Value name="5">
<Value>HotelName</Value>
</Value>
<Value name="6">
<Value>PositiveMarkersSum</Value>
</Value>
<Value name="7">
<Value>NegativeMarkersSum</Value>
</Value>
<Value name="8">
<Value>EmotionalSum</Value>
</Value>
<Value name="9">
<Value>NumberOfSentences</Value>
</Value>
<Value name="10">
<Value>NumberOfEntities</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="iknowAV.Hotels.Stat.Statistics">
<Super>%RegisteredObject</Super>
<TimeChanged>63415,38458.778916</TimeChanged>
<TimeCreated>63393,40728.632605</TimeCreated>

<Method name="Mean">
<ClassMethod>1</ClassMethod>
<FormalSpec>valueList:%List</FormalSpec>
<ReturnType>%Numeric</ReturnType>
<Implementation><![CDATA[
	
	set sum = 0
	set length = $listlength(valueList)
	
	if (length = 0) { return ""}
	
	for i=1:1:length
	{
		set sum = sum + $list(valueList, i)
	}
	
	return sum / length
]]></Implementation>
</Method>

<Method name="Variance">
<ClassMethod>1</ClassMethod>
<FormalSpec>valueList:%List</FormalSpec>
<ReturnType>%Numeric</ReturnType>
<Implementation><![CDATA[
	set sum = 0
	set length = $listlength(valueList)
	set mean = ..Mean(valueList)
	
	if (length = 0) { return ""}
	
	for i=1:1:length  
	{
		set sum = sum + $zpower(($list(valueList,i) - mean), 2)
	}	
	
	return sum / length
]]></Implementation>
</Method>

<Method name="StdDev">
<ClassMethod>1</ClassMethod>
<FormalSpec>valueList:%List</FormalSpec>
<ReturnType>%Numeric</ReturnType>
<Implementation><![CDATA[	return $zsqr(..Variance(valueList))
]]></Implementation>
</Method>
</Class>




<Class name="iknowAV.stat.Article">
<Description>
Класс, содержащий рассчитанную информацию о статьях в домене</Description>
<Super>%Persistent</Super>
<TimeChanged>63378,58994.484108</TimeChanged>
<TimeCreated>63328,42484.099239</TimeCreated>

<Property name="DomainName">
<Description>
Имя домена, в котором находится статья</Description>
<Type>%String</Type>
</Property>

<Property name="SourceID">
<Description>
ID статьи</Description>
<Type>%Integer</Type>
</Property>

<Property name="PubDate">
<Description>
Дата публикации статьи (по выбору это либо дата публикации либо дата загрузки в домен)</Description>
<Type>%Date</Type>
</Property>

<Property name="PubTime">
<Description>
Время публикации/загрузки в домен статьи</Description>
<Type>%Integer</Type>
</Property>

<Property name="Positive">
<Description>
Счтетчик позитивных маркеров</Description>
<Type>%Integer</Type>
<InitialExpression>"0"</InitialExpression>
</Property>

<Property name="Negative">
<Description>
Счетчик негативных маркеров</Description>
<Type>%Integer</Type>
<InitialExpression>"0"</InitialExpression>
</Property>

<Property name="Emotion">
<Description>
Флаг эмоции, 1-positive,0-neutral,-1-negative</Description>
<Type>%Integer</Type>
<InitialExpression>"0"</InitialExpression>
</Property>

<Property name="EmoGrade">
<Description>
Итоговая степень эмоциональной окраски статьи, сумма Positive и Negative</Description>
<Type>%Integer</Type>
<InitialExpression>"0"</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="ClearEmotions">
<Description>
Обнуление всех предварительно расчитанных значений, возвращает количество обнуленных записей
domName - домен, для которого выполняется действие</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	
	for i=1:1 {
		set article = ##class(iKnowAV.stat.Article).%OpenId(i)
		if (article'="") {
			if (article.DomainName = domName) {
				set article.Positive = 0
				set article.Negative = 0
				set article.Emotion = 0
				set article.EmoGrade = 0
				do article.%Save()
			}
		}
		else {
			return i-1
			}
	}
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="UpdateEmotions">
<Description>
Рассчет эмоциональной окраски по накопленным значениям счетчиках позитывных и негативных маркеров
domName - домен, для которого выполняется действие</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	// расчитываем эмоциональную окраску по накопленным позитивным и негативным маркерам
	for i=1:1 {
		set article = ##class(iKnowAV.stat.Article).%OpenId(i)
		if (article'="") 
		{
			if (article.DomainName = domName) {
				set article.EmoGrade = article.Positive - article.Negative
				if (article.EmoGrade>0) {set article.Emotion = 1}
				elseif (article.EmoGrade<0) {set article.Emotion = -1}
				else {set article.Emotion=0}
				do article.%Save()
			}
		}
		else {
			return i-1
			}
	}
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^iknowAV.stat.ArticleD</DataLocation>
<DefaultData>ArticleDefaultData</DefaultData>
<IdLocation>^iknowAV.stat.ArticleD</IdLocation>
<IndexLocation>^iknowAV.stat.ArticleI</IndexLocation>
<StreamLocation>^iknowAV.stat.ArticleS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="ArticleDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>DomainName</Value>
</Value>
<Value name="3">
<Value>SourceID</Value>
</Value>
<Value name="4">
<Value>PubDate</Value>
</Value>
<Value name="5">
<Value>PubTime</Value>
</Value>
<Value name="6">
<Value>Positive</Value>
</Value>
<Value name="7">
<Value>Negative</Value>
</Value>
<Value name="8">
<Value>Emotion</Value>
</Value>
<Value name="9">
<Value>EmoGrade</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="iknowAV.util.GetFullArticleText">
<Description>
Методы класса заменяют текст статей, взятый из кратких RSS-лент, на полные тексты, доступные по ссылкам из RSS
Класс создан для поиска способов зачитывания полного текста в домен, должен тестироваться и дорабатываться</Description>
<Super>%Persistent</Super>
<TimeChanged>63328,56328.224141</TimeChanged>
<TimeCreated>63328,54234.153013</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="ReplaceSourceWithFullTextForLastProcess">
<Description>
заменяет статьи на полные версии
domName - имя домена, для которого выполняется действие</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	s sc = ..BuildGlobalOfExistingID(domName)	
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="ReplaceSourceWithFullText">
<Description>
	Функция заменяет текст статьи на полный текст из ссылки
domName - имя домена, для которого выполняется действие
	sourceID - id cnfnmb</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,sourceID:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim sc As %Status
	
	#dim fullLink as %String	
	#dim server As %String
	#dim url As %String
	#dim text As %String
	
	if (##class(%iKnow.Domain).Exists(domName)) {
		s domainId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} else {
		return $$$ERROR("Error: domain " + domName + " not found")
	}
	
	set fullLink = ##class(%iKnow.Queries.MetadataAPI).GetValueById(domainId, 4, sourceID)	
	
	set fullLink = $piece(fullLink,"//",2)		//cut beginning "http://"
	set server = $piece(fullLink,"/",1)			//server name is the beginning of string (www.reuters.com)
	set url = $replace(fullLink,server,"")		//url is the full ling without server name (/article/2014/04/01/us-games-koreas-idUSBREA3009B20140401)
	
	// get data of old source
	set tObj = ##class(%ZEN.proxyObject).%New()
	set tObj.sourceId = sourceID
	set tObj.externalId = ##class(%iKnow.Queries.SourceAPI).GetExternalId(domainId, sourceID)
	set tObj.title = ##class(%iKnow.Queries.MetadataAPI).GetValue(domainId, "Title", tObj.externalId)
	set tObj.pubDate = ##class(%iKnow.Queries.MetadataAPI).GetValue(domainId, "PubDate", tObj.externalId)
	set tObj.agency = ##class(%iKnow.Queries.MetadataAPI).GetValue(domainId, "Agency", tObj.externalId)
	set tObj.link = ##class(%iKnow.Queries.MetadataAPI).GetValue(domainId, "Link", tObj.externalId)
	set tObj.country = ##class(%iKnow.Queries.MetadataAPI).GetValue(domainId, "Country", tObj.externalId)	
	
	/*set ^tObject("sourceId") = tObj.sourceId
	set ^tObject("externalId") = tObj.externalId	
	set ^tObject("title") = tObj.title	
	set ^tObject("pubDate") = tObj.pubDate	
	set ^tObject("agency") = tObj.agency
	set ^tObject("link") = tObj.link
	set ^tObject("country") = tObj.country
	*/
	
	// create new global
	if (tObj.agency="Reuters")
	{
		set sc = ..ParseFullTextReuters(server, url, .text)
		set ^RSSFullTextTempGlobal(1) = text		
	}
	else {quit $$$ERROR("Unknown Agency recieved")}
	
	// create global lister	
	set confName = "Conf"_domName
	#dim loader As %iKnow.Source.Loader = ##class(iKnow.InterlotMain).CreateLoader(domName)
	#dim lister As %iKnow.Source.Global.Lister = ##class(iKnow.InterlotMain).CreateListerGlobal(domName, confName)	
	set sc = loader.SetLister(lister)
	
	// delete old source
	//set sc = ##class(%iKnow.Source.Loader).DeleteSource(domainId,SourceID)
		
	// load text
	set gbl = "^RSSFullTextTempGlobal"
	set sc = loader.ProcessList(gbl,1)	// gbl - globalname, 1 index (^RSSFullTextTempGlobal(1))
	if sc '= 1 {write "ProcessList error ",$System.Status.DisplayError(sc),! }
	
	// fill metadata for new source
	set newSourceId = ##class(%iKnow.Queries.SourceAPI).GetSourceId(domainId, ":GLOBAL:^RSSFullTextTempGlobal(1)")
	w "newSourceId is: ", newSourceId,!
	do ##class(%iKnow.Queries.MetadataAPI).SetValueById(domainId, 2, newSourceId, tObj.pubDate)
	do ##class(%iKnow.Queries.MetadataAPI).SetValueById(domainId, 3, newSourceId, tObj.title)
	do ##class(%iKnow.Queries.MetadataAPI).SetValueById(domainId, 4, newSourceId, tObj.link)
	do ##class(%iKnow.Queries.MetadataAPI).SetValueById(domainId, 5, newSourceId, tObj.agency)
	do ##class(%iKnow.Queries.MetadataAPI).SetValueById(domainId, 6, newSourceId, tObj.country)
	
	kill ^RSSFullTextTempGlobal(1)
	
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ClassMethod GetMidArticle(Server As %String, Url As %String, Pointer As %Integer) As %Status

]]></Content>
</UDLText>

<Method name="BuildGlobalOfExistingID">
<ClassMethod>1</ClassMethod>
<FormalSpec>DomainName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	if (##class(%iKnow.Domain).Exists(DomainName)) {
		s domainId = ##class(%iKnow.Domain).GetOrCreateId(DomainName)
	} else {
		w "Error: domain " + DomainName + " not found"
		return NULL
	}
	
	k ^gExSources
	k ^iKnowTemp
	
	for j=1:1 
	{
		w "current j = ",j,!
		set sc = ##class(%iKnow.Queries.SourceAPI).GetByDomain("^iKnowTemp", domainId, j, 10)
		break:(sc'=1)
				
		
		if (sc'=1) {
			 return $$$ERROR("No added sources id found") }
			 
		for i=1:1:10{
			s k=10*(j-1)+i
			w "current i = ",k,!
			
			if ($isobject(^iKnowTemp(k)) =0 ) {quit}
			
			set id=$LIST(^iKnowTemp(k),1)
			w "   id(",10*(j-1)+i,") = ",id,!
			s ^gExSources(id)=1
			//s i=i+1
		}
	}
	
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// SPECIAL FUNCTIONS FOR PARSING REUTERS HTML NEWS ARTICLES

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="ParseFullTextReuters">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Server:%String,Url:%String,&Result:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set Result = ""
	#dim header As %String = ""
	#dim text As %String = ""	
	
	set sc = ..GetFocusParagraph(Server,Url,.header)
	if ($$$ISERR(sc)) {quit sc}
	set sc = ..GetMidArticle(Server,Url,.text)
	if ($$$ISERR(sc)) {quit sc}
	
	set Result = header_$$$EOL_text
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ClassMethod GetFocusParagraph(Server As %String, Url As %String, Pointer As %Integer, ByRef Result As %String) As %Status

]]></Content>
</UDLText>

<Method name="GetFocusParagraph">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Server:%String,Url:%String,&Result:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 set searchfocus="=""focusParagraph"">"
 set cleanfocus="n"_$c(34)_">"
 
 set Result = ""

 set req = ##class(%Net.HttpRequest).%New()
 set req.Server = Server
 set tSC = req.Get(Url)
 set tStream = req.HttpResponse.Data
 While ('tStream.AtEnd) {
        set text=tStream.ReadLine(,.sc)
        set find=$find(text,searchfocus)
        if (find>0) {
	        set temp=$e(text,find,$l(text))
	        set piece=$piece(temp,"</span>",2,999)
	        set tmpdata=$piece(piece,"</p>",1)
			      
	        if ($e(tmpdata,1,$l(cleanfocus))=cleanfocus) {
	       		set tmpdata=$e(tmpdata,$l(cleanfocus)+1,$l(tmpdata))
	    	}
        	// clean the span's in the text
        	while (1) {
	       		set len=$l(tmpdata,"(<span ") 
	       		if (len<2) quit
	       		set first=$piece(tmpdata,"(<span ",1)
	       		set second=$piece(tmpdata,"(<span ",2,999)
	       		set rest=$piece(second,"</span>)",2,999)
	       		set tmpdata=first_rest
        	}
        	set tmpdata=$replace(tmpdata,"&nbsp;","")
        	set tmpdata=$piece(tmpdata,"(<span ",1)
	        set tmpdata=$piece(tmpdata,"<span ",1)
	        set tmpdata=$piece(tmpdata,"(Reuters)",2,999)
	        
	        s Result = tmpdata
	        
        	//s ^RSSFEEDSFocus(Pointer)=$lb(tmpdata)
        	//w "Data written",!,tmpdata,!
		 }
 } // end while
 
 quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ClassMethod GetMidArticle(Server As %String, Url As %String, Pointer As %Integer) As %Status

]]></Content>
</UDLText>

<Method name="GetMidArticle">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Server:%String,Url:%String,&Result:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 set searchfocus="<span id=""midArticle_"
 //set counter=0	
 
 set Result = ""
 set req = ##class(%Net.HttpRequest).%New()
 set req.Server = Server
 set tSC = req.Get(Url)
 set tStream = req.HttpResponse.Data
 While ('tStream.AtEnd) {
        set text=tStream.ReadLine(,.sc)
        set position=1
        set first=1
        set find=$find(text,searchfocus)
        while (1) {
	        set find=$find(text,searchfocus,position)
	        quit:find=0
	        set position=find
	        set char=$extract(text,find,find)
	        // skip entry id="midArticle_start
	        if (char="s") {
		        continue
	        }
	        if (char="0") && (first=1) {
		        set first=0
		        continue
	        }
	        set temp=$e(text,find,$l(text))
	        set piece=$piece(temp,"</span>",2,999)
	        set piece=$piece(piece,"<p>",2)
	        set tmpdata=$piece(piece,"</p>",1)
	        if (tmpdata="") {
		        continue
	        }
	        //set counter=counter+1
	        
	        set tmpdata=$replace(tmpdata,"&nbsp;","")
	        set tmpdata=$piece(tmpdata,"(<span ",1)
	        set tmpdata=$piece(tmpdata,"<span ",1)
	        
	        //if ($find(tmpdata,"(Editing by",1)>0) {continue}
	        	        
	        /*
	        // remove <a href ...> tags
	        set ahrefStart = $find(tmpdata,"<a",1)
	        if (ahrefStart>0) {set ahrefStart = ahrefStart-2}
	       	set ahrefEnd = $find(tmpdata,">",1)
	        if (ahrefEnd>0) {set ahrefEnd = ahrefEnd-1}
	        set $extract(tempdata,ahrefStart,ahrefEnd) = ""
	        set tmpdata=$replace(tmpdata,"</a>","")
	        */
	        
	        
	        set Result = Result_tmpdata_$$$EOL
	        
        	//set ^RSSFEEDSMidArticle(Pointer,counter)=$lb(tmpdata)
        	//w "Data written",!,tmpdata,!
		 }
 } // end while
 quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^iknowAV.util.GetFullArti445DD</DataLocation>
<DefaultData>GetFullArticleTextDefaultData</DefaultData>
<IdLocation>^iknowAV.util.GetFullArti445DD</IdLocation>
<IndexLocation>^iknowAV.util.GetFullArti445DI</IndexLocation>
<StreamLocation>^iknowAV.util.GetFullArti445DS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="GetFullArticleTextDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="iknowAV.util.main">
<Description>
general functions of iKnow domain creation</Description>
<IncludeCode>%IKPublic</IncludeCode>
<Super>%XML.Adaptor</Super>
<TimeChanged>63416,34796.000733</TimeChanged>
<TimeCreated>63321,57740.708854</TimeCreated>

<Method name="Create">
<Description>
Сохдание нового домена и конфигурации
domName - имя создаваемого домена, используется также при создании конфигурации с приставкой "conf",
domFolder - имя папки, где находятся файлы словарей, используемых при создании домена (пример пути "C:\ARTEM\Interlot\Files\")
getFullText - параметр, отвечающий за использование полного текста статей, вместо rss-лент. Пока не реализован</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,domFolder:%String,getFullText:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/* установка заначения пути к файлам словарей для домена, 
	выполняется 1 раз при создании домена, в последствии может быть заменена только вручную */
	
	set ^iknowAVDomainFolder(domName) = domFolder
	set ^iknowAVDomainFolder(domName,"loadNumber") = 0
	
	#dim confName As %String = "Conf"_domName
	#dim domain As %iKnow.Domain = ..CreateDomain(domName)
	#dim domId As %Integer = ..GetDomainId(domName)
	 
	if '($data(domId)) { return $$$ERROR("Domain does not exist.") }
	 
	write "ID of new domain: ", domId,!
	
	// Конфигурация создается для листера	
	#dim configuration As %iKnow.Configuration = ..CreateConfiguration(domName, confName) 
	
	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="LoadRSS">
<Description>
Загрузка домена из RSS-лент
добавляет новые статьи в уже существующий домен, обновляет словари по актуальным версиям файлов
возвращает количество добавленных статей
domName - имя создаваемого домена, используется также при создании конфигурации с приставкой "conf", 
для обновления домена используются файлы: 
1. Sources.txt - список загружаемых rss-лент
2. Dictionary.txt -  список проверочных слов и выражений для разделения статей по темам
3. BlackList.txt - список слов и выражений, которые не будут распознаваться как концепты
4. Emotions.txt - список основ слов, характеризующих эмоциональную окраску статей
Все файлы находятся в папке ^iknowAVDomainFolder(domName)
writeLog - флаг записи лог-файла при обновлении. Log-файл с именем updateLog.txt в рабочем каталоге домена</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,domFolder:%String,writeLog:%Integer=0</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	
	// Если домен не существует, создаем новый (так же создается конфигуация)
	do ..CreateDomainIfNotExists(domName, domFolder)
	
	#dim confName As %String = "Conf"_domName
	#dim domId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	#dim initialNumOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)
	#dim listerRSS As %iKnow.Source.RSS.Lister = ..CreateListerRSS(domName, confName)
	
	// Создаем поля метаданных
	do ..SetMetaDataFields(domName)	
	// Cоздаем словари для matching								
	do ..CreateDictionaries(domName)		
	// Формируем черные списки						
	do ..CreateBlackLists(domName, "GeneralBlackList")			
	
	// Файл со списком источников
	#dim filename As %String = ^iknowAVDomainFolder(domName)_"Sources.txt"
	
	// Запускаем процесс обработки источников
	do ..ProcessRSSListersFromFile(domName, listerRSS, filename, writeLog)	
	
	// Матчим источники
	write "   matching sources...",!
	set status = ##class(%iKnow.Matching.MatchingAPI).MatchSources(domId)	
	
	if (status = $$$OK)
	{
		write "   sources are matched",!	
	}
	else
	{
		write "Error, matching sources", status, !
	}		
		

	#dim numOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)
	
	// Статистика загруженных источников (было, загружено, стало)		
	write "Initial number of sources : ", initialNumOfSources, !
	write "Sources Added : ", numOfSources - initialNumOfSources, !
	write "Total : ", numOfSources, !
		
	return (numOfSources - initialNumOfSources)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="LoadFile">
<Description>
Загрузка домена из файлов указанной директории
добавляет новые статьи в уже существующий домен, обновляет словари по актуальным версиям файлов
возвращает количество добавленных статей
domName - имя создаваемого домена, используется также при создании конфигурации с приставкой "conf", 
для обновления домена используются файлы: 
1. Sources.txt - список загружаемых rss-лент
2. Dictionary.txt -  список проверочных слов и выражений для разделения статей по темам
3. BlackList.txt - список слов и выражений, которые не будут распознаваться как концепты
4. Emotions.txt - список основ слов, характеризующих эмоциональную окраску статей
Все файлы находятся в папке ^iknowAVDomainFolder(domName)
writeLog - флаг записи лог-файла при обновлении. Log-файл с именем updateLog.txt в рабочем каталоге домена</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,domFolder:%String,sourceFilesPath:%String,writeLog:%Integer=0</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[

	// Если домен не существует, создаем новый (так же создается конфигуация)	
	do ..CreateDomainIfNotExists(domName, domFolder)
	
	#dim confName As %String = "Conf"_domName
	#dim domId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	#dim initialNumOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)
	#dim listerFile As %iKnow.Source.File.Lister = ..CreateListerFile(domName, confName)				// листер File
	#dim loader As %iKnow.Source.Loader = ..CreateLoader(domName)	// лоадер создается для домена
	
	// Создаем словари для matching
	do ..CreateDictionaries(domName)
	// Формируем черные списки							
	do ..CreateBlackLists(domName, "GeneralBlackList")			
	
	// Добавляем файл в список на обработку
	// 3 параметр - смотреть в подпапках, 4 - фильтр
	set status = listerFile.AddListToBatch(sourceFilesPath, $lb("txt"), 0, "") 
	
	// Если что-то не так, выдаем текст ошибки
	if '(status = $$$OK) 
	{ 
		zwrite status
	}
	
	// Запускаем обработку
	set status = loader.ProcessBatch()

	// Если что-то не так, выдаем текст ошибки	
	if '(status = $$$OK) 
	{
		zwrite status
	}
		
	// Матчим источники
	write "   matching sources...",!
	set status = ##class(%iKnow.Matching.MatchingAPI).MatchSources(domId)
		
	if (status = $$$OK)
	{
		write "   sources are matched",!	
	}
	else
	{
		write "Error, matching sources", status, !
	}		
		
	#dim numOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)

	// Статистика загруженных источников (было, загружено, стало)	
	write "Initial number of sources : ", initialNumOfSources,!
	write "Sources Added : ", numOfSources - initialNumOfSources,!
	write "Total : ", numOfSources,!
		
	return (numOfSources - initialNumOfSources)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="LoadDomain">
<Description>
Загрузка домена из существующего домена
добавляет новые статьи в уже существующий домен, обновляет словари по актуальным версиям файлов
возвращает количество добавленных статей
domName - имя создаваемого домена, используется также при создании конфигурации с приставкой "conf", 
для обновления домена используются файлы: 
1. Sources.txt - список загружаемых rss-лент
2. Dictionary.txt -  список проверочных слов и выражений для разделения статей по темам
3. BlackList.txt - список слов и выражений, которые не будут распознаваться как концепты
Все файлы находятся в папке ^iknowAVDomainFolder(domName)
writeLog - флаг записи лог-файла при обновлении. Log-файл с именем updateLog.txt в рабочем каталоге домена</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,domFolder:%String,sourceDomName:%String,writeLog:%Integer=0</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	
	// Проверяем, существуетли домен-источник. 
	// Если нет, то выдаем ошибку.
	if '(##class(%iKnow.Domain).Exists(sourceDomName)) 
	{
		write "Source domain " _ sourceDomName _ " does not exist.", !
		return $$$ERROR()
	}
	else
	{
		#dim sourceDomId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(sourceDomName)
	}
	
	
	// Если домен не существует, создаем новый (так же создается конфигуация)	
	do ..CreateDomainIfNotExists(domName, domFolder)
	
	#dim confName As %String = "Conf"_domName
	#dim domId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	#dim initialNumOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)
	#dim listerDomain As %iKnow.Source.Domain.Lister = ..CreateListerDomain(domName, confName)	// листер домена

	// Создаем словари для matching	
	do ..CreateDictionaries(domName)
	// Формируем черные списки								
	do ..CreateBlackLists(domName, "GeneralBlackList")			
	// Лоадер создается для домена
	#dim loader As %iKnow.Source.Loader  = ..CreateLoader(domName)

	// Добавляем домен-источник в список на обработку 
	set status = listerDomain.AddListToBatch(sourceDomId)
	
	// Если что-то не так, выдаем текст ошибки
	if '(status = $$$OK)
	{
		zwrite status
	}
	
	write "sourceDomId is: ", sourceDomId, !
	
	// Копируем поля метаданных из домена-источника в целевой домен
	do ##class(%iKnow.Utils.CopyUtils).CopyMetadataFields(sourceDomId, domId, 1, 1)
	
	// Запускаем процесс обработки источников
	set status = loader.ProcessBatch()
	
	// Копируем значения полей метаданных из домена-источника в целевой домен
	do ..CopyMetadataValues(domId, sourceDomId, initialNumOfSources)	
	
	// Матчим источники
	write "   matching sources...",!
	set status = ##class(%iKnow.Matching.MatchingAPI).MatchSources(domId)	
	if (status = $$$OK)
	{
		write "   sources are matched",!	
	}
	else
	{
		write "Error, matching sources", status, !
	}		
	
	#dim numOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)

	// Статистика загруженных источников (было, загружено, стало)	
	write "Initial number of sources : ", initialNumOfSources,!
	write "Sources Added : ", numOfSources - initialNumOfSources,!
	write "Total : ", numOfSources,!
		
	return (numOfSources - initialNumOfSources)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="TransferDomain">
<Description>
Ручная (поисточниковая) загрузка домена из существующего домена
Нужна для копирования домена с поврежденными источниками.
Для загрузки только корректных источников нужно использовать LoadDomain.
возвращает количество добавленных статей
domName - имя создаваемого домена, используется также при создании конфигурации с приставкой "conf", 
для обновления домена используются файлы: 
1. Sources.txt - список загружаемых rss-лент
2. Dictionary.txt -  список проверочных слов и выражений для разделения статей по темам
3. BlackList.txt - список слов и выражений, которые не будут распознаваться как концепты
4. Emotions.txt - список основ слов, характеризующих эмоциональную окраску статей
Все файлы находятся в папке ^iknowAVDomainFolder(domName)
writeLog - флаг записи лог-файла при обновлении. Log-файл с именем updateLog.txt в рабочем каталоге домена</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,domFolder:%String,sourceDomName:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	
	// Проверяем, существуетли домен-источник. 
	// Если нет, то выдаем ошибку.	
	if '(##class(%iKnow.Domain).Exists(sourceDomName)) 
	{
		write "Source domain " _ sourceDomName _ " does not exist.", !
		return $$$ERROR()
	}
	else
	{
		#dim sourceDomId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(sourceDomName)
	}	
	
	// Если домен не существует, создаем новый (так же создается конфигуация)
	do ..CreateDomainIfNotExists(domName, domFolder)	
	
	#dim confName As %String = "Conf"_domName
	#dim domId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	#dim initialNumOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)

	// Создаем словари для matching
	do ..CreateDictionaries(domName)
	// Формируем черные списки							
	do ..CreateBlackLists(domName, "GeneralBlackList")			
	// Лоадер создается для домена	
	#dim loader As %iKnow.Source.Loader  = ..CreateLoader(domName)	
	
	write "sourceDomId is: ", sourceDomId, !
	
	// Копируем поля метаданных из домена-источника в целевой домен	
	do ##class(%iKnow.Utils.CopyUtils).CopyMetadataFields(sourceDomId, domId, 1, 1)
	
	// Количество источников домена-источника
	#dim sourceDomainNumOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(sourceDomId)
	
	// Цикл по всем источникам домена-источника
	for i=1:1:sourceDomainNumOfSources 
	{
		// Получаем внешний Id источника
		set ext =  ##class(%iKnow.Queries.SourceAPI).GetExternalId(sourceDomId, i, .status)
		
		write !, "Processing source #", i, " ExtId = ", ext, ":", !
		write "Loading started: ", $zdatetime($horolog), !
		
		if (status '= $$$OK) 
		{	
			write "Processing failed.", !
			zw status
			continue
		}
		
		set status = ##class(%iKnow.Queries.SentenceAPI).GetBySource(.tSentences, sourceDomId, i, 0, 0)
		
		if (status '= $$$OK) 
		{
			write "Processing failed.", !
			zw status
			continue
		}
		
		// Получаем полный текст источника
		set sourceText = ""
		#dim k = ""
		
		// Цикл по всем предложениям источника и "склейка" их в один текст
		for 
		{
			set k = $order(tSentences(k), 1, tSentData)
			quit:k=""
			
			set tSentID = $li(tSentData,1)
			
			set sourceText = sourceText _ " " _ ##class(%iKnow.Queries.SentenceAPI).GetValue(sourceDomId, tSentID)
		}
		
		set ^a = sourceText
		
		// Обрабатываем истоник
	 	do loader.BufferSource(ext, ^a)
	 	set status = loader.ProcessBuffer(confName)
	 	
	 	// Если не ОК, выводим текст ошибки и обрабатываем следующий источник
		if (status '= $$$OK)
		{
			zw status
			continue
		}
		
		#dim newExt = ":TEMP:" _ ext

		// Получаем массив полей метаданных			
		set status = ##class(%iKnow.Queries.MetadataAPI).GetFields(.fields, domId)
	 	
	 	// Если не ОК, выводим текст ошибки и обрабатываем следующий источник			
		if (status '= $$$OK) 
		{ 
			zw status
			continue
		}

		// Копируем значение полей метаданных источника из домена-источника в новый домен
		// Цикл по полям метаданных				
		set next = 1
		write "Starting copy metadata..", !	
		for 
		{
			set next = $order(fields(next))
			   
			   quit:next=""
			   
			   #dim fieldName As %String = $list(fields(next), 2) 
			   set value = ##class(%iKnow.Queries.MetadataAPI).GetValue(sourceDomId, fieldName, oldExt, .status)
			   
			   if '(status = $$$OK) { continue }
			   
			   set status = ##class(%iKnow.Queries.MetadataAPI).SetValue(domId, fieldName, newExt, value)
			   
			   if '(status = $$$OK) { continue }
			 
		}
	 	
		write "Copy metadata complete.", !	
		write "Loading finished: ", $zdatetime($horolog), !
	}
	
	// матчим источники
	write "   matching sources...",!
	set status = ##class(%iKnow.Matching.MatchingAPI).MatchSources(domId)	
	if (status = $$$OK)
	{
		write "   sources are matched",!	
	}
	else
	{
		write "Error, matching sources", status, !
	}		
	
	#dim numOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)
	
	// Статистика загруженных источников (было, загружено, стало)	
	write "Initial number of sources : ", initialNumOfSources,!
	write "Sources Added : ", numOfSources - initialNumOfSources,!
	write "Total : ", numOfSources,!
		
	return (numOfSources - initialNumOfSources)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CopyMetadataValues">
<Description>
Копирование значения метаданных источников одного домена в другой
Используетя только из метода LoadDomain
domId  - ID домена, в который производится копирование значений метаданных
sourceDomId -  ID домена, из которого производится копирование значений метаданных
initialNumOfSources - количество источников в новом домене до начала LoadDomain (необходимо для копирования 
метаданных только новых источников</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domId:%Integer,sourceDomId:%Integer,initialNumOfSources:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	write !, "Starting copy metadata values.. ", !
	
	#dim numOfSources As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)	
	#dim i As %Integer
	#dim status As %Status
	
	for i = initialNumOfSources+1:1:numOfSources 
	{
		#dim externalId = ##class(%iKnow.Queries.SourceAPI).GetExternalId(domId, i, .status)
		
	 	// Если не ОК, выводим текст ошибки и обрабатываем следующий источник
		if (status '= $$$OK)
		{
			zw status
			continue
		}
		
		// Получаем массив полей метаданных
		set status = ##class(%iKnow.Queries.MetadataAPI).GetFields(.fields, domId)
		
	 	// Если не ОК, выводим текст ошибки и обрабатываем следующий источник
		if (status '= $$$OK)
		{
			zw status
			continue
		}
		
		// Копируем значение полей метаданных источника из домена-источника в новый домен
		// Цикл по полям метаданных	
		set next = 1
		for 
		{
			set next = $order(fields(next))

			quit:next=""

			#dim fieldName As %String = $list(fields(next), 2) 
			set value = ##class(%iKnow.Queries.MetadataAPI).GetValue(sourceDomId, fieldName, externalId, .status)

			// Если не ОК, выводим текст ошибки и обрабатываем следующий источник
			if '(status = $$$OK) { continue }

			set status = ##class(%iKnow.Queries.MetadataAPI).SetValue(domId, fieldName, externalId, value)

			// Если не ОК, выводим текст ошибки и обрабатываем следующий источник
			if '(status = $$$OK) { continue }

		}
	}
	
	write "Metadata values copy complete successfully. ", !
	
	return $$$OK
]]></Implementation>
</Method>

<Method name="Free">
<Description>
Удаление домена со всем окружением
domName - имя домена</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	k ^iknowAVDomainFolder(domName)
	#dim confName As %String = "Conf"_domName

	// Удалаем поля метаданных	
	do ..RemoveMetaDataFields(domName)		
	// Удаляем словари для matching	
	do ..DeleteDictionaries(domName)
	// Удаляем черные списки				
	do ..DeleteBlackLists(domName, "GeneralBlackList")	
	// Удаляем конфигурацию
	#dim status As %Status = ..DeleteConfiguration(confName)
	
	if (status '= $$$OK)	
	{	
		write "Cannot delete configuration :", confName, !	
	}
	
	// Удаляем домен
	set status = ..DeleteDomain(domName)
	
	if (status '= $$$OK)	
	{	
		write "Cannot delete configuration :", confName, !	
	}
	
	return status
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="PrintDomainInfo">
<Description>
Выводит в консоль основную информацию о домене</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	if (##class(%iKnow.Domain).Exists(domName))
	{
		#dim domainID As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	}
	else
	{
		write "   domain ",domName," does not exist",!
	}	
	
	#dim sourceNumber As %Integer = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domainID)
	
	
	write "   domain name   = ", domName, !
	write "   domain ID     = ", domainID, !
	write "   domain folder = ", ^iknowAVDomainFolder(domName), !
	write "   sources       = ", sourceNumber, !
	
	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CreateDomain">
<Description>
Создание нового домена
domName - имя создаваемого домена</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%iKnow.Domain</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName))
	{
		#dim domain As %iKnow.Domain = ##class(%iKnow.Domain).Open(domName)
		write "   open domain ", domName, " ", !
	}
	else
	{
		set domain = ##class(%iKnow.Domain).%New(domName)
		do domain.%Save()
		do domain.SetParameter($$$IKPSTEMMING, 1)	
		do domain.%Save()
		
		write "   domain ", domName, " created!", !
	}
	return domain
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="DeleteDomain">
<Description>
Удаление домена со всеми данными
domName - имя удаляемого домена</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) {
		set domain  = ##class(%iKnow.Domain).Open(domName)
		set domainId = domain.Id
		set tSC = ##class(%iKnow.Domain).DeleteId(domainId)	
		
		if (tSC = $$$OK) {
			write "Domain ", domName, " deleted successfully.", !
			return $$$OK
		}
		else {
			write "Error: failed to delete domain ", domName, !
			return $$$ERROR()
		}
	}
	else {
		write "Domain ", domName, " doesn't exist", !
		return $$$ERROR()
	}
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CreateConfiguration">
<Description>
Создание конфигурации, используется при создании листера
domName - имя текущего домена
confName - имя создаваемой конфигурации</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,confName:%String</FormalSpec>
<ReturnType>%iKnow.Configuration</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Configuration).Exists(confName))
	{
		#dim configuration AS %iKnow.Configuration = ##class(%iKnow.Configuration).Open(confName)
		write "   open congiguration ",confName," ",!
	}
	else
	{
		//#dim filename As %String = ^iknowAVDomainFolder(domName)_"Substitution.txt"
		
		set userDictionaryName = "MyUserDict" 
		
		set udict = ..CreateUserDictionary(userDictionaryName)
	
		s configuration = ##class(%iKnow.Configuration).%New(confName,0,"ru",udict.Name,1)
		//set configuration = ##class(%iKnow.Configuration).%New(confName,1,$lb("en","ru"),filename,1)		
		//s configuration = ##class(%iKnow.Configuration).%New(confName,0,"ru")
		set configuration.StemmingConfig = "DEFAULT"
		do configuration.%Save()
		write "   configuration ",confName," created!",!
	}
	
	return configuration
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="DeleteConfiguration">
<Description>
Удаление конфигурации
confName - имя удаляемой конфигурации</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>confName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Configuration).Exists(confName))
	{
		#dim configuration As %iKnow.Configuration = ##class(%iKnow.Configuration).Open(confName)
		#dim configurationId As %Integer = configuration.Id
		#dim status As %Status = ##class(%iKnow.Configuration).DeleteId(configurationId)
		
		if (status = $$$OK)
		{
			write "   configuration ",confName," deleted",!
			return $$$OK
		}
		else
		{
			write "   Error: failed to delete configuration ",confName,!
			return $$$ERROR()
		}
	}
	else
	{
		write "   configuration ",confName," doesn't exist",!
		return $$$ERROR()
	}
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CreateLoader">
<Description>
Создание лоадера, создается для домена (по имени домена)
domName - имя домена, для которого создается загрузчик</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%iKnow.Source.Loader</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) 
	{
		#dim domainId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} 
	else 
	{
		write "Error: domain " + domName + " not found"
		return NULL
	}
	
	#dim loader As %iKnow.Source.Loader = ##class(%iKnow.Source.Loader).%New(domainId)	

	return loader
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CreateListerRSS">
<Description>
Создание листера RSS, создается для домена (по имени домена)
domName - имя домена, для которого создается листер
confName - имя конфигурации, которая будет применяться в листере</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,confName:%String</FormalSpec>
<ReturnType>%iKnow.Source.RSS.Lister</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) 
	{
		#dim domainId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} 
	else 
	{
		write "Error: domain " + domName + " not found"
		return NULL
	}
	
	#dim lister As %iKnow.Source.RSS.Lister = ##class(%iKnow.Source.RSS.Lister).%New(domainId)	
	
	do lister.SetConfig(confName)	
	do lister.SetConverter("%iKnow.Source.Converter.Html")
	
	write "   lister created!",!
	
	return lister
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CreateListerDomain">
<Description>
Создание листера домена, создается для домена (по имени домена)
domName - имя домена, для которого создается листер
confName - имя конфигурации, которая будет применяться в листере</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,confName:%String</FormalSpec>
<ReturnType>%iKnow.Source.Domain.Lister</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) 
	{
		#dim domainId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	}
	else 
	{
		write "Error: domain " + domName + " not found"
		return NULL
	}
	
	#dim lister As %iKnow.Source.Domain.Lister = ##class(%iKnow.Source.Domain.Lister).%New(domainId)
	do lister.SetConfig(confName)

	write "   lister created!", !
	
	return lister
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CreateListerFile">
<Description>
Создание файлового листера, создается для домена (по имени домена)
domName - имя домена, для которого создается листер
confName - имя конфигурации, которая будет применяться в листере</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,confName:%String,converter:%Integer=1</FormalSpec>
<ReturnType>%iKnow.Source.File.Lister</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) 
	{
		#dim domainId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} 
	else 
	{
		write "Error: domain " + domName + " not found"
		return NULL
	}
	
	#dim lister As %iKnow.Source.File.Lister = ##class(%iKnow.Source.File.Lister).%New(domainId)	
	
	do lister.SetConfig(confName)
	
	write "   lister created!",!
	
	return lister
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CreateListerGlobal">
<Description>
Создание листера Для глобалов, создается для домена (по имени домена)
domName - имя домена, для которого создается листер
confName - имя конфигурации, которая будет применяться в листере
converter - параметр выбора конвертера, по умолчанию 0 для HTML (прочие не реализованы), использовался для загрузке полного текста статей по ссылке из RSS</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,confName:%String,converter:%Integer=0</FormalSpec>
<ReturnType>%iKnow.Source.Global.Lister</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) 
	{
		#dim domainId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} 
	else 
	{
		write "Error: domain " + domName + " not found"
		return NULL
	}
	
	#dim lister As %iKnow.Source.Global.Lister = ##class(%iKnow.Source.Global.Lister).%New(domainId)	
	
	do lister.SetConfig(confName)
	
	if (converter=0)
	{
		do lister.SetConverter("%iKnow.Source.Converter.Html")
	}
	else
	{
		do lister.SetConverter("%iKnow.Source.Converter")
	}	
	
	write "   lister created!",!
	
	return lister
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="WriteSummary">
<Description>
Формирование резюме для указанного источника
domName - имя домена, в котором проводится действие
sourceId - идентификатор статьи, по которой требуется сделать резюме
summaryLength - длина резюме в предложениях</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,sourceId:%Integer,summaryLength:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim summary As %String = ""
	
	if (##class(%iKnow.Domain).Exists(domName)) 
	{
		#dim domainId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} 
	else 
	{
		write "Error: domain " + domName + " not found"
		return NULL
	}
	//set tSC = ##class(%iKnow.Queries.SourceAPI).GetSummary(.summary, domainId, sourceId, summaryLength)
	set summary = ##class(%iKnow.Queries.SourceAPI).GetSummaryDirect(domainId, sourceId, summaryLength)	
	
	write summary, !
	
	return summary
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="GetTopConcepts">
<Description>
Формирование списка из наиболее популярных концептов
domName - имя домена, в котором проводится действие
numElements - число наиболее популярных концептов, которое надо вывести
useBL - флаг использования фильтрации по черным спискам</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,numElements:%Integer=10,useBL:%Integer=0</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[

	if (##class(%iKnow.Domain).Exists(domName)) 
	{
		#dim domainId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} 
	else 
	{
		w "Error: domain " + domName + " not found"
		return 0
	}
	
	write "current domain ID is : ", domainId,!
	
	set sc = $$$OK
	set blackListId = ##class(%iKnow.Utils.MaintenanceAPI).GetBlackListId(domainId, "GeneralBlackList", .sc)
	
	if ( (sc=1) && (useBL>0) ) 
	{
		set sc = ##class(%iKnow.Queries.EntityAPI).GetTop(.result, domainId, 1, numElements, "", $$$FILTERONLY, $$$SORTBYDOMAINDEFAULT, $$$ENTTYPECONCEPT, 0, blackListId)
	} 
	else 
	{
		set sc = ##class(%iKnow.Queries.EntityAPI).GetTop(.result, domainId, 1, numElements)
	}

	for i=1:1:numElements
	{
		write i, ". ", $list(result(i),2),!
	}
	
	return sc
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="SetMetaDataFields">
<Description>
Установка дополнительных полей метаданных для статей, возвращает количество созданных полей данных
domName - имя домена, в котором проводится действие
редактировать совместно с ..RemoveMetaDataFields</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	#Include %IKPublic	
	if (##class(%iKnow.Domain).Exists(domName)) {
		set domainId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} else {
		write "Error: domain " + domName + " not found"
		return 0
	}	
	set val = ##class(%iKnow.Queries.MetadataAPI).AddField( domainId,"PubDate",,$$$MDDTDATE )
	set val = ##class(%iKnow.Queries.MetadataAPI).AddField( domainId,"Title",,$$$MDDTSTRING )
	set val = ##class(%iKnow.Queries.MetadataAPI).AddField( domainId,"Link",,$$$MDDTSTRING )
	set val = ##class(%iKnow.Queries.MetadataAPI).AddField( domainId,"Agency",,$$$MDDTSTRING )	
	set val = ##class(%iKnow.Queries.MetadataAPI).AddField( domainId,"Topic",,$$$MDDTSTRING )
	set val = ##class(%iKnow.Queries.MetadataAPI).AddField( domainId,"Category",,$$$MDDTSTRING )
	
	// 1 is standard DataIndexed, plus 6 added manually
	if (val = 7)
	{
		write "all metadata fields are created - total ", val, !
	}
	else
	{
		write "errors creating metadata fields - total ", val, !
	}
	return val
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="RemoveMetaDataFields">
<Description>
Удаление дополнительных полей, используется при обновлении и удалении домена, возвращает число удаленных полей
domName - имя домена, в котором проводится действие
редактировать совместно с ..SetMetaDataFields</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) 
	{
		#dim domainId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} 
	else 
	{
		write "Error: domain " + domName + " not found"
		return 0
	}
	
	#dim status As %Status = ##class(%iKnow.Queries.MetadataAPI).RemoveField( domainId,"PubDate" )
	set status = status + ##class(%iKnow.Queries.MetadataAPI).RemoveField( domainId,"Title" )
	set status = status + ##class(%iKnow.Queries.MetadataAPI).RemoveField( domainId,"Link" )
	set status = status + ##class(%iKnow.Queries.MetadataAPI).RemoveField( domainId,"Agency" )
	set status = status + ##class(%iKnow.Queries.MetadataAPI).RemoveField( domainId,"Topic" )
	set status = status + ##class(%iKnow.Queries.MetadataAPI).RemoveField( domainId,"Category" )
	
	if (status = 6)
	{
		write "all metadata fields are deleted",!
	}
	else
	{
		write "errors in deleting metadata fields",!
	}
		
	return status
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CreateDictionaries">
<Description>
создание словарей по файлу, путь к файлу ^iknowAVDomainFolder(domName) + "Dictionary.txt"
domName - имя домена, в котором проводится действие
формат файла, идентификаторы строк: "!" - комментарий, "d" - словарь, "i"-группа терминов, "t"-термин</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	if (##class(%iKnow.Domain).Exists(domName)) 
	{
		#dim domainId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} 
	else 
	{
		write "Error: domain " + domName + " not found"
		return $$$ERROR()
	}
	
	#dim filename As %String = ^iknowAVDomainFolder(domName)_"Dictionary.txt"
	#dim stream As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
	set sc = stream.LinkToFile(filename)
	
	set i = 0
	
	#dim dictId = 0
	#dim itemId = 0
	#dim language = 0
		
	while '(stream.AtEnd) 
	{		
		set line = stream.ReadLine()
		
		// проверка строки на комментарий (начинается с !)		
		set checkComment = $PIECE(line,"!",1,1)
		if (checkComment="") {continue}
		
		// обработка строки
		set stype = $piece(line,"#",1)
		set i = i + 1
		
		if (stype="d") 
		{
			// добавляем словарь
			set language = $piece(line,"#",4)
			set dictId = ##class(%iKnow.Matching.DictionaryAPI).CreateDictionary( domainId, $piece(line,"#",2), $piece(line,"#",3),language,"",.status )
			write "   dictionary ", $piece(line,"#",2), " created",!
		}		// elseif (stype="d")
		elseif (stype="i") 
		{
			// добавляем item
			set ref = ""
			set itemId = ##class(%iKnow.Matching.DictionaryAPI).CreateDictionaryItem( domainId, dictId, $piece(line,"#",2), .ref, language)
		}		// elseif (stype="i")
		elseif (stype="t") 
		{
			// парсим строку с терминами, разделенными запятой
			set dList = $piece(line,"#",2)
			set j = 1
			while $piece(dList,",",j)'="" 
			{	
				set termId = ##class(%iKnow.Matching.DictionaryAPI).CreateDictionaryTerm( domainId, itemId, $piece(dList,",",j), language)	
				set j = j + 1
			}
		}		// elseif (stype="t")
	}		// 'stream.AtEnd
			
	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="DeleteDictionaries">
<Description>
удаление словарей
domName - имя домена, в котором проводится действие</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) {
		set domainId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} else {
		write "Error: domain " + domName + " not found"
		return $$$ERROR()
	}
	
	do ##class(%iKnow.Matching.DictionaryAPI).DropAllDictionaryData(domainId)
	write "   all dictionaries are deleted",!
	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="UpdateDictionaries">
<Description>
обновление словарей, вместо старых словарей формируются новые по файлу dictionary.txt, затем проводится переиндексация статей в домене
domName - имя домена, в котором проводится действие</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ..DeleteDictionaries(domName)			// удаляем словари для matching
	do ..CreateDictionaries(domName)			// создаются словари для matching
	
	if (##class(%iKnow.Domain).Exists(domName)) {
		set domainId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} else {
		write "Error: domain " + domName + " not found"
		return $$$ERROR()
	}
		
	write "   matching sources...",!
	set status = ##class(%iKnow.Matching.MatchingAPI).MatchSources(domainId)	
	if (status = 1)
	{
		write "   sources are matched",!	
	}
	else
	{
		write "Error, matching sources", status, !	
	}
	set numOfSources = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domainId)
	write "Sources Loaded : ", numOfSources,!
	
	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CreateBlackLists">
<Description>
Метод создаёт черные списки по файлу BlackList.txt, 
содержит построчно перечисленные термины, "!" - в начале строки символ комментария
domName - имя домена, в котором проводится действие
BLName - имя формируемого в домене черного списка</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,BLName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) {
		set domainId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} else {
		write "Error: domain " + domName + " not found"
		return $$$ERROR()
	}
	
	set blackListId = ##class(%iKnow.Utils.MaintenanceAPI).CreateBlackList(domainId, BLName)
	
	set filename = ^iknowAVDomainFolder(domName)_"BlackList.txt"
	set stream = ##class(%Stream.FileCharacter).%New()
	set sc = stream.LinkToFile(filename)
	
	while 'stream.AtEnd {		
		set line = stream.ReadLine()
		
		// порверка строки на комментарий, определяется "!" в начале строки
		set checkComment = $PIECE(line,"!",1,1)
		if (checkComment="") {continue}
		
		set sc = ##class(%iKnow.Utils.MaintenanceAPI).AddStringToBlackList(domainId, blackListId, line)
		write "   line: ",line," added to black list",!
	}

	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="DeleteBlackLists">
<Description>
Метод удаляет черный список
domName - имя домена, в котором проводится действие
BLName - имя удаляемого в домене черного списка</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,BLName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) {
		set domainId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} else {
		write "Error: domain " + domName + " not found"
		return $$$ERROR()
	}
	
	if ( 0 = ##class(%iKnow.Utils.MaintenanceAPI).HasBlackLists(domName) )
	{
		write "   no black lists found",!
		return $$$OK	
	}
	set blackListId = ##class(%iKnow.Utils.MaintenanceAPI).GetBlackListId(domainId, BLName)
	set sc = ##class(%iKnow.Utils.MaintenanceAPI).DropBlackList(domainId, blackListId)
	
	if (sc=$$$OK)
	{	
		write "   black list deleted",!}
	else 
	{
		write "Error deleting black list",!
		write sc,!
	}
	
	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="UpdateBlackLists">
<Description>
Метод обновляет или создаёт черные списки по файлу BlackList.txt, 
содержит построчно перечисленные термины, "!" - в начале строки символ комментария
domName - имя домена, в котором проводится действие
BLName - имя формируемого в домене черного списка</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,BLName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (##class(%iKnow.Domain).Exists(domName)) {
		set domainId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} else {
		write "Error: domain " + domName + " not found"
		return $$$ERROR()
	}
	
	set sc = ..DeleteBlackLists(domName, BLName)
	if (sc = $$$OK)
	{
		write "BlackList ",BLName, " deleted",!	
	}
	
	set sc = ..CreateBlackLists(domName, BLName)
	if (sc = $$$OK)
	{
		write "BlackList ",BLName, " created",!	
	}	

	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="FillRSSListersFromFile">
<Description>
Задание для RSS листера набора источников из файла
формат записи об источнике в файле
casino.ru#/rss/news.xml#Agency#Category
listerRSS - указатель на листер, созданный ранее
filename - имя файла с источниками (..DOMAINFOLDER + "Sources.txt")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>listerRSS:%iKnow.Source.RSS.Lister,filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	set stream = ##class(%Stream.FileCharacter).%New()
	set sc=stream.LinkToFile(filename)
	write "Link to file status: ",sc,!
	
	while 'stream.AtEnd {
		
		set line = stream.ReadLine()
		
		// проверка строки комментария (начинается с "!")		
		set checkComment = $PIECE(line,"!",1,1)
		if (checkComment="") {continue}
			
		set server = $PIECE(line,"#",1,1)
		set url = $PIECE(line,"#",2,2)
		set source = $PIECE(line,"#",3,3)
		set category = $PIECE(line,"#",4,4)
		
		do listerRSS.RegisterFixedMetadata($lb("Agency", "Category"), $lb(source, category))
		set status = listerRSS.AddListToBatch(server, url, "Atom2.0", 1)	
		write line,!
	
	}	

	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="ProcessRSSListersFromFile">
<Description>
Загрузка статей по источникам из файла
формат записи об источнике в файле
casino.ru#/rss/news.xml#Agency#Category
domName - имя домена
listerRSS - указатель на листер, созданный ранее
writeLog - флаг записи лог-файла при обновлении. Log-файл с именем updateLog.txt в рабочем каталоге домена
filename - имя файла с источниками (..DOMAINFOLDER + "Sources.txt")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,listerRSS:%iKnow.Source.RSS.Lister,filename:%String,writeLog:%Integer=0,getFullText:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ^iknowAVDomainFolder(domName,"loadNumber") = ^iknowAVDomainFolder(domName,"loadNumber") + 1	// increase loading number by 1
	
	if (##class(%iKnow.Domain).Exists(domName)) {
		set domId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} else {
		write "Error: domain " + domName + " not found"
		return $$$ERROR()
	}
	
	set stream = ##class(%Stream.FileCharacter).%New()
	set sc=stream.LinkToFile(filename)
	write "Link to file status: ",sc,!
	write "Loading data from sources ...",!
	
	if (writeLog = 1)
	{
		set logFile = ^iknowAVDomainFolder(domName)_"logFiles\"_"updateLog_"_^iknowAVDomainFolder(domName,"loadNumber")_".txt"
		set file = ##class(%File).%New(logFile)
		do file.Open("WSN")
		do file.Rewind()
		do file.Write("Loading started: ")
		do file.WriteLine($zdatetime($horolog))
	}
	
	#dim counter As %Integer = 0
	while 'stream.AtEnd {
		
		set numOfSources0 = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)
		
		set counter = counter + 1
		set line = stream.ReadLine()
		
		// проверка строки комментария (начинается с "!")		
		set checkComment = $PIECE(line,"!",1,1)
		if (checkComment="") {continue}
			
		set server = $PIECE(line,"#",1,1)
		set url = $PIECE(line,"#",2,2)
		set source = $PIECE(line,"#",3,3)
		set category = $PIECE(line,"#",4,4)
		
		#dim loader As %iKnow.Source.Loader = ..CreateLoader(domName)	// лоадер создается для домена
		do listerRSS.RegisterFixedMetadata($lb("Agency", "Category"), $lb(source, category))
		set status = listerRSS.AddListToBatch(server, url, "Atom2.0", 1)
		
		set time0 = $zdatetime($horolog)
		write counter,".  ",server,url," started: ", time0
		if (writeLog = 1) {	do file.Write(counter_".  "_server_url_" started: "_time0)}
		
		set status = loader.ProcessBatch()
		set numOfSources1 = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)	// новое количество источников в домене
		
		set time1 = $zdatetime($horolog)
		
		if (writeLog = 1) {	do file.Write(" finished: "_time1)}
		
		write " finished: ", time1,!
		write "status is: "				
		if (status '= $$$OK)
		{
			do $system.Status.DisplayError(status)
			do loader.GetErrors(.result)
			zw result
			if (writeLog = 1) {	
				do file.Write(" with errors ")
			}			
			write !
		}
		else
		{
			write "OK",!
		}
		
		write " sources loaded: ", numOfSources1-numOfSources0,!
		
		
		if (writeLog = 1) 
		{
			set line = "  sources loaded: "_(numOfSources1-numOfSources0)
			do file.WriteLine(line)
		}
		
		// при успешной загрузке, замена кратких текстов новостей из лент на полные варианты, доступные по ссылкам для последних загруженных новостей
		if ((status=$$$OK) && (getFullText=1))
		{
			set sc = ##class(iKnow.Utils.ParseHtml).ReplaceSourceWithFullTextForLastProcess(domName)
		}
	
	}	// while


	if (writeLog = 1) 
	{
		do file.Write("Loading finished: ")
		do file.WriteLine($zdatetime($horolog))
		do file.WriteLine()
		do file.%Save()
	}
	
	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="TestRSSSourcesInFile">
<Description>
filename - имя файла с источниками </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	// create test domain infrastructure
	set domName = "testDomain"
	set confName = "Conf"_domName
	set domain = ..CreateDomain(domName)								// создание тестового домена
	set domId = ##class(%iKnow.Domain).GetOrCreateId(domName)

	write "ID of temporary test domain: ", domId,!
	
	if (##class(%iKnow.Configuration).Exists(confName))					// создание тестовой конфигурации
	{
		set configuration = ##class(%iKnow.Configuration).Open(confName)
		write "   open congiguration ",confName," ",!
	}
	else
	{		
		set configuration = ##class(%iKnow.Configuration).%New(confName,1,$lb("en","ru"),"",1)		
		do configuration.%Save()
	}
	
	set loader = ..CreateLoader(domName)								// лоадер создается для домена
	set listerRSS = ..CreateListerRSS(domName, confName)				// листер RSS
	
	set stream = ##class(%Stream.FileCharacter).%New()
	set sc=stream.LinkToFile(filename)
	write "Link to file status: ",sc,!
	
	set sourcesLoaded0 = 0
	set sourcesLoaded1 = 0
	set counter = 1
	
	write "Testing sources from ",filename,!,!
	
	// проверка загрузки статей из источников по-одному
	while 'stream.AtEnd {
		
		set line = stream.ReadLine()
				
		// проверка строки комментария (начинается с "!")		
		set checkComment = $PIECE(line,"!",1,1)
		if (checkComment="") {continue}
			
		set server = $PIECE(line,"#",1,1)
		set url = $PIECE(line,"#",2,2)
		set source = $PIECE(line,"#",3,3)
		set category = $PIECE(line,"#",4,4)	

		write counter_".   ",server,url,!
		set loader=##class(%iKnow.Source.Loader).%New(domId)				// лодер
		set lister=##class(%iKnow.Source.RSS.Lister).%New(domId)			// листер RSS
		do lister.SetConverter("%iKnow.Source.Converter.Html")				// конвертер HTML
		
		set sourcesLoaded0 = sourcesLoaded1	
		do listerRSS.RegisterFixedMetadata($lb("Agency", "Category"), $lb(source, category))
		set status = listerRSS.AddListToBatch(server, url, "Atom2.0", 1)
		set status = loader.ProcessBatch()	
		if (status '= $$$OK) {
			d $system.Status.DisplayError(status)
			write !
			set status = loader.GetFailed(.result, 1)
			zw result
			write !
		}
		set sourcesLoaded1 = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domId)
		write "          "_sourcesLoaded1-sourcesLoaded0,!
		set counter = counter+1	
	}	
	
	// удаление домена и конфигурации
	set status = ..DeleteConfiguration(confName)
	set status = ..DeleteDomain(domName)

	return $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CreateArticles">
<Description>
Создание экземпляров класса iKnow.stat.Article, возвращает количество созданных экземпляров
domName - имя домена, для статей которого выполняется операция</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	#dim articlesCreated As %Integer = 0	// счетчик созданных классов статей
	if (##class(%iKnow.Domain).Exists(domName)) {
		set domainId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} else {
		write "Error: domain " + domName + " not found"
		return 0
	}
	set articlesTotal = ##class(%iKnow.Queries.SourceAPI).GetCountByDomain(domainId)	// полное число статей в домене
	
	set sc = ##class(%iKnow.Queries.SourceAPI).GetByDomain(.result,domainId,1,articlesTotal)	// получение листа статей по домену
	
	//merge ^t = result
	#dim i As %Integer = 1
	set p = ""
	for {
		set p = $O(result(p))		
		quit:(p = "")		
		set sourceId = $list(result(i),1)
		
		//-----------------------------
		// создание объекта для sourceID
		set newArticle = ##class(iKnowAV.stat.Article).%New()
		set newArticle.SourceID = sourceId
		set newArticle.DomainName = domName		
		
		set datetime = ##class(%iKnow.Queries.MetadataAPI).GetValueById(domainId, 1, sourceId,.sc)	//1-время загрузки лоадером, 2 - время публикации (может влиять на статистику, время публикации может быть пустым в зависимости от rss-ленты)	
		set newArticle.PubDate = $piece(datetime,",",1)
		if ($piece(datetime,",",2)'="") {
			set time = $piece(datetime,",",2)/3600
			set newArticle.PubTime = $piece(time,".",1)
		}
		else {
			set newArticle.PubTime = ""
		}
		set stat = newArticle.%Save()
		//-----------------------------

		set i = i + 1
		
	}
	
	return i-1
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="CalcArticlesEmotionGrade">
<Description>
Расчет эмоцилнальной окраски статей в домене,
выполняется по словарю эмоциональных маркеров из файла ^iknowAVDomainFolder(domName)_"Emotions.txt"
поиск подходящих маркеров в тексте производится по ПОХОЖИМ концептам
domName - имя домена, для статей которого выполняется операция </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// очищаем переменные, накапливающие сведения об эмоциях
	do ##class(iKnowAV.stat.Article).ClearEmotions(domName)
	
	if (##class(%iKnow.Domain).Exists(domName)) {
		set domainId = ##class(%iKnow.Domain).GetOrCreateId(domName)
	} else {
		write "Error: domain " + domName + " not found"
		return $$$ERROR()
	}	
	//загрузка файла со словарем маркеров эмоционального окраса

	set filename = ^iknowAVDomainFolder(domName)_"Emotions.txt"
	set stream = ##class(%Stream.FileCharacter).%New()
	set sc = stream.LinkToFile(filename)
	
	set i=0
	while 'stream.AtEnd {		
		set line = stream.ReadLine()
		
		// check if line is a comment (starts with !)		
		set checkComment = $PIECE(line,"!",1,1)
		if (checkComment="") {continue}
				
		// Обрабатываем строку
		set sValue = $piece(line,"#",1)	// получаем вес терминов
		set i=i+1
		
		// парсим строку с терминами, разделенными запятой
		set dList = $piece(line,"#",2)
		set j = 1
		while $piece(dList,",",j)'="" 
		{	
			// $piece(dList,",",j) текущий термин
			set entityValue = $piece(dList,",",j)
			
			// определяем число похожих концептов в домене
			set lbNumber = ##class(%iKnow.Queries.EntityAPI).GetSimilarCounts(domainId, entityValue)
			
			set number = $list(lbNumber,1)	// первый элемент списка - количество похожих концептов
			if (number = 0) {
				set j=j+1
				continue
			}
			//w "   found similar to: ", entityValue,!
			
			// получение id для похожих концептов
			kill similarResult
			set st = ##class(%iKnow.Queries.EntityAPI).GetSimilar(.similarResult,domainId,entityValue,1,number)	// 1 страница с number результатами
			if (st '= 1) continue
			
			set k1 = 1
			set p1 = ""
			for 
			{	// цикл по похожим концептам
				set p1 = $O(similarResult(p1))	
				quit:(p1 = "")
				set similarEntityId = $list(similarResult(k1),1)				
				
				//w "		term found: ", $list(similarResult(k1),2),!
				set numberOfArticlesWithSE = $list(similarResult(k1),3)
				// получаем список статей, содержащих данный концепт
				kill result
				set st = ##class(%iKnow.Queries.SourceAPI).GetByEntityIds(.result, domainId, $lb(similarEntityId), 1, numberOfArticlesWithSE)				
				set k2 = 1
				set p2 =""
				for {					// цикл по статьям содержащим концепт
					set p2 = $O(result(p2))	
					quit:(p2 = "")
					// id статьи в sourceId		
					set sourceId = $list(result(k2),1)	
					// задача - получить id для объекта iKnowAV.stat.Article
					&sql(SELECT ID INTO :id FROM  iKnowAV_stat.Article WHERE SourceID = :sourceId AND DomainName = :domName)
					//write "%ID for ",sourceId," is: ",id,!
					// открываем объект типа  iKnowAV.stat.Article по ID
					set source = ##class(iKnowAV.stat.Article).%OpenId(id,-1,.status)
					// добавляем в соответствующее поле весовое значение 					
					if (status = 1)
					{
						if (sValue>0)	{set source.Positive = source.Positive+sValue}
						else			{set source.Negative = source.Negative-sValue}
						do source.%Save()
					}
					set k2=k2+1					
				}	// for
				
				set k1=k1+1
				
			}	// for		
					
			set j=j+1
			
		}		// while
					
	}		// 'stream.AtEnd
	
	// пересчитываем итоговые оценки
	do ##class(iKnowAV.stat.Article).UpdateEmotions(domName)
	
	return 1
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// =================================================================================================

]]></Content>
</UDLText>

<Method name="GetDomainId">
<Description>
Метод, возвращающий DomainId по имени домена.
domName - имя домена.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	// Проверяем, существует ли домен. 
	// Если да - возвращаем id.
	// Если нет - выдаем ошибку, что такого домена нет.
	if (##class(%iKnow.Domain).Exists(domName)) 
	{
		#dim domId As %Integer = ##class(%iKnow.Domain).GetOrCreateId(domName)
	}
	else 
	{
		write "Error: domain " + domName + " not found"
		return ""
	}
	 
	return domId
]]></Implementation>
</Method>

<Method name="CreateDomainIfNotExists">
<Description>
Метод инициализации домена.
Если домен не существует, создаем новый с конфигурацией по указанной папке.
Вызывается в методах LoadRSS(), LoadDomain(), LoadFile(), TransferDomain()
domName - имя домена
domFolder - путь к папке домена</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>domName:%String,domFolder:%String</FormalSpec>
<Implementation><![CDATA[
	if '(##class(%iKnow.Domain).Exists(domName)) 
	{
		write "Domain " _ domName _ " does not exist.", !
		
		if '($data(domFolder)) 
		{
			write "Please, specify the domain folder.", !
			write "Ex.: Load(""MyDomain"", ""C:\Domains\Example\"")", !
			
			return $$$ERROR("The domain's folder does not specified.")
		}
		else 
		{
			write "Creating new domain: " _ domName, !
				
			#dim status As %Status = ..Create(domName, domFolder)
			
			if (status = $$$OK) 
			{
				write "New domain " _ domName _ " was created successfully.", !	
			}
			else 
			{
				return status
			}
		}	
		
	}
]]></Implementation>
</Method>

<Method name="CreateUserDictionary">
<Description>
Метод, производящий инициализацию пользовательского словаря
userDictionaryName - имя пользовательского словаря</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>userDictionaryName:%String</FormalSpec>
<ReturnType>%iKnow.UserDictionary</ReturnType>
<Implementation><![CDATA[
		
		// Пробуем открыть существующий словарь
		set udict = ##class(%iKnow.UserDictionary).OpenByName(userDictionaryName) 
		
		// Если получилось, то удаляем его 
		// (так как мы не знаем, что в нем содержится, лучше создать новый)
		if (udict '= "")
		{
			do ##class(%iKnow.UserDictionary).%DeleteId(udict.Id)
		}
		
		// Создаем новый словарь
		set udict = ##class(%iKnow.UserDictionary).%New(userDictionaryName) 
		do udict.%Save()
		
		// Заполняем словарь элементами
		do udict.AddEntry("))))",".")
		do udict.AddEntry(")))",".")
		do udict.AddEntry("))",".")
		do udict.AddEntry(". ",".")
		do udict.AddEntry(".....",".")
		do udict.AddEntry("...",".")
		do udict.AddEntry("..",".")
		do udict.AddEntry(".",". ")
		do udict.AddEntry("!!!!!","!")
		do udict.AddEntry("!!!","!")
		do udict.AddEntry("!!","!")
		do udict.AddEntry("!","! ")
		do udict.AddEntry("?????","?")
		do udict.AddEntry("???","?")
		do udict.AddEntry("??","?")
		do udict.AddEntry("?","? ")
		do udict.AddEntry(",",", ")
		
		//Сохраняем словарь
		do udict.%Save()
		
		return udict
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// ===========================================================================================

]]></Content>
</UDLText>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^iknowAV.util.mainD</DataLocation>
<DefaultData>mainDefaultData</DefaultData>
<IdLocation>^iknowAV.util.mainD</IdLocation>
<IndexLocation>^iknowAV.util.mainI</IndexLocation>
<StreamLocation>^iknowAV.util.mainS</StreamLocation>
<Data name="mainDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="iknowAV.util.routines">
<Description>
класс содержит методы для запуска и тестирования функций по работе с доменом</Description>
<Super>%RegisteredObject</Super>
<TimeChanged>63363,52806.049869</TimeChanged>
<TimeCreated>63363,52701.119859</TimeCreated>

<Method name="RunUpdateForDomain">
<Description>
обновляет в бесконечном цикле два домена</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	while 1
		{
		do ##class(iknowAV.util.main).Update("WC01",1)
		do ##class(iknowAV.util.main).PrintDomainInfo("WC01")
		
		hang 600
		
		do ##class(iknowAV.util.main).Update("WC02",1)
		do ##class(iknowAV.util.main).PrintDomainInfo("WC02")
		
		hang 600
	}	// while
	return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="iknowAV.view.Reader">
<IncludeCode>%IKInclude</IncludeCode>
<Super>%ZEN.Component.page</Super>
<TimeChanged>63337,64462.657284</TimeChanged>
<TimeCreated>62810,43692.246071</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// Property Domain As %Integer [ InitialExpression = {##class(News.NewsDomain).%GetDomainId()} ];

]]></Content>
</UDLText>

<Property name="Domain">
<Type>%Integer</Type>
<InitialExpression>##class(%iKnow.Domain).GetOrCreateId("WC02")</InitialExpression>
</Property>

<Property name="CurrentPage">
<Description>
ID of the domain used by this demo
Current page of results</Description>
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="CurrentAction">
<Description>
Current action, as selected by the user</Description>
<Type>%String</Type>
</Property>

<Property name="SelectedSource">
<Description>
Source ID as selected by the user when clicking on an action</Description>
<Type>%Integer</Type>
</Property>

<Property name="Agency">
<Description>
Agency filter, if selected by the user (Module 3, exercise 4)</Description>
<Type>%String</Type>
</Property>

<Property name="SummaryLength">
<Description>
Length of the summary to be displayed in the article reading pane (Module 3, exercise 6)</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SelectedEntity">
<Description>
Entity ID as selected by the user when clicking on an entity (Module 3, exercise 6)</Description>
<Type>%Integer</Type>
</Property>

<Property name="Topic">
<Description>
Topic filter, if selected by the user (Module 4, exercise 4)</Description>
<Type>%String</Type>
</Property>

<Property name="Date">
<Description>
Date filter, if selected by the user (Module 4, exercise 4)</Description>
<Type>%String</Type>
</Property>

<Property name="Category">
<Description>
Category filter, if selected by the user (Module 4, exercise 4)</Description>
<Type>%String</Type>
</Property>

<Property name="FavoritesDictionary">
<Description>
Name of the dictionary containing "favorite terms" (Module 4, exercise 5)</Description>
<Type>%String</Type>
<InitialExpression>"My Favorites"</InitialExpression>
</Property>

<Property name="Subtitle">
<Description><![CDATA[
Subtitle, as derived by <method>RefreshTables</method>]]></Description>
<Type>%String</Type>
<InitialExpression>"Recent articles"</InitialExpression>
</Property>

<Property name="InputConfig">
<Description>
Name of the configuration to use for indexing manual input</Description>
<Type>%String</Type>
<InitialExpression>"AllLanguages"</InitialExpression>
</Property>

<XData name="Contents">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page title="News reader" layout="vertical" width="100%" height="100%" >
<titleBox title="News reader" titleStyle="font-size: 28px;" />
<hgroup width="100%" cellVAlign="middle">
<label id="lblSubtitle" label="#(%page.Subtitle)#" width="80%"
labelStyle="font-size: 20px;" />

<select label="Domain" id="selDomain"
queryClass="%iKnow.Domain" queryName="GetAllDomains" showEmpty="false" 
onchange="zenPage.onChangeDomain();">
<parameter value="#(%page.Domain)#" />
</select>
<spacer width="10" />
<select label="Agency" id="selAgency"
queryClass="%iKnow.Queries.MetadataQAPI" queryName="GetFieldValues"
onchange="zenPage.onChangeFilters();">
<parameter value="#(%page.Domain)#" />
<parameter value="Agency" />
</select>
<spacer width="10" />
<select label="Category" id="selCategory"
queryClass="%iKnow.Queries.MetadataQAPI" queryName="GetFieldValues"
onchange="zenPage.onChangeFilters();">
<parameter value="#(%page.Domain)#" />
<parameter value="Category" />
</select>
<spacer width="10" />
<select label="Topic" id="selTopic"
queryClass="%iKnow.Matching.DictionaryQAPI" queryName="GetDictionaries"
onchange="zenPage.onChangeFilters();">
<parameter value="#(%page.Domain)#" />
</select>
<spacer width="10" />
<image src="deepsee/ds2_compose_44.png" enclosingStyle="padding-top:5px;"
   onclick="zen('modInput').show();" height="40" />
<spacer width="10" />
<image src="deepsee/ds2_bookmarks_44.png" enclosingStyle="padding-top:5px;"
  onclick ="zen('showArticle').show();"
   height="40" />
<spacer width="10" />
<image src="deepsee/ds2_house_44.png" enclosingStyle="padding-top:5px;"
   onclick="zenPage.reset();" height="40" />
</hgroup>
<spacer height="20" />
<tablePane id="tblSources" caption="Articles" rowSelect="false" showRowSelector="false" nowrap="0"
sql="SELECT SourceId, ExternalId FROM iknowAV_view.Sources" width="100%">
<column colName="ID" hidden="true" />
<column colName="ExternalId" hidden="true" />
<column header="Date" OnDrawCell="DrawSourceMetaDate" seed="PubDate" style="text-align:center;" />
<column header="Title" OnDrawCell="DrawSource" style="padding:5px; white-space:normal;"   />
<column header="Agency" OnDrawCell="DrawSourceMeta" seed="Agency" />
<column header="Category" OnDrawCell="DrawSourceMeta" seed="Category" />
<column header="Actions" OnDrawCell="DrawSourceActions" style="text-align:center;" />
</tablePane>
<hgroup width="100%" cellAlign="right">
<button caption="&lt;&lt;" onclick="zenPage.nextPage(-1);" />
<spacer width="5" />
<button caption="&gt;&gt;" onclick="zenPage.nextPage(+1);" />
</hgroup>

<modalGroup id="modArticle" >
<titleBox id="titArticle" />
<vgroup enclosingClass="articleText">
<html id="htmlArticle" OnDrawContent="DrawArticle" />
<hgroup cellAlign="right" width="100%" labelPosition="left">
<text title="Summary length" size="2" id="txtSummaryLength" onkeyup="zenPage.summarize();" />
<spacer width="20" />
<image src="deepsee/ds2_notepad_44.png" height="22" title="Indexing results"
	onclick="zenPage.goToUI('IndexingResults');" />
<spacer width="10" />
<image src="deepsee/ds2_palette_44.png" height="22" title="Matching results"
	onclick="zenPage.goToUI('MatchingResults');" />
</hgroup>
</vgroup>
</modalGroup>

<modalGroup id="showArticle" >
<titleBox id="titShowArticle" />
<vgroup enclosingClass="articleText">
<html id="htmlShowArticle" OnDrawContent="DrawArticle" />
<hgroup cellAlign="right" width="100%" labelPosition="left">
<text title="Summary length" size="2" id="txtArticleId" />
<spacer width="20" />
<button caption="show" onclick="zenPage.showArticle();" />
</hgroup>
</vgroup>
</modalGroup>

<modalGroup id="modInput" labelPosition="left" cellStyle="padding-bottom:8px">
<titleBox title="Manual input" />
<text id="txtInputTitle" label="Title" size="50" />
<textarea id="txtInputText" cols="40" rows="10" label="Article" />
<hgroup cellAlign="right" width="100%">
<button caption="save" onclick="zenPage.submitInput();" />
</hgroup>
</modalGroup>

<modalGroup id="modMatches" >
<titleBox title="Matching results" />
<spacer height="10" />
<tablePane id="tblDictScores" 
queryClass="%iKnow.Matching.MatchingQAPI" queryName="GetTotalDictionaryScoresBySourceId">
<parameter value="#(%page.Domain)#" />
<parameter value="#(%page.SelectedSource)#" />
</tablePane>
</modalGroup>

</page>
]]></Data>
</XData>

<Method name="RefreshTables">
<Description>
Refreshes the contents of the main sources table based on the values of the different page
properties containing the current action, user selections and filter criteria</Description>
<ReturnType>%Status</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK, tTitle = ""
	try {
		
		// create filter object (Module 3, exercise 4)
		set tFilter = ""
		if (..Agency'="") {
			set tFilter = ##class(%iKnow.Filters.SimpleMetadataFilter).%New(..Domain, "Agency", "=", ..Agency)
			set tTitle = " ("_..Agency_")"
		}
		
		set tFilter = ""
		if (..Category'="") {
			set tFilter = ##class(%iKnow.Filters.SimpleMetadataFilter).%New(..Domain, "Category", "=", ..Category)
			set tTitle = " ("_..Category_")"
		}
		
		// append a topic filter if required (Module 4, exercise 4)
		if (..Topic'="") {
			
			set tFilter2 = ##class(%iKnow.Filters.SimpleMatchFilter).%New(..Domain, ..Topic, 1)
			
			// combine filters
			if (tFilter="") {
				set tFilter = tFilter2
			} else {
				set tGrpFilter = ##class(%iKnow.Filters.GroupFilter).%New(..Domain, 1)
				do tGrpFilter.AddSubFilter(tFilter)
				do tGrpFilter.AddSubFilter(tFilter2)
				set tFilter = tGrpFilter
			}
			
			// retrieve dictionary name
			set tDict = ##class(%iKnow.Objects.Dictionary).PKINDEXOpen(..Domain, ..Topic)
			set tTitle = tTitle _ " ("_tDict.Name_")"
			
			
			// forward to RefreshTablesTopDict for favorites dictionary
			if (tDict.Name = ..FavoritesDictionary) {
				set tTitle = "My Favorites" _ tTitle
				set tSC = ..RefreshTablesTopDict(tDict.Name)
				quit // always quit, we populated the table inside RefreshTablesTopDict()
			}
			
		}
		
		// populate sources table
		if (..CurrentAction = "similarSources") && ..SelectedSource {
			
			set tSelSourceExtId = ##class(%iKnow.Queries.SourceAPI).GetExternalId(..Domain, ..SelectedSource)
			set tSelSourceTitle = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "Title", tSelSourceExtId)
			
			// show the sources similar to ..SelectedSource (Module 3, exercise 4)
			set tSC = ##class(%iKnow.Queries.SourceAPI).GetSimilar("^News.Results.Sources", ..Domain, ..SelectedSource, ..CurrentPage,, tFilter)
			set tTitle = "Articles related to ""<i>"_tSelSourceTitle_"</i>"""_tTitle
			
		} elseif (..CurrentAction = "byEntity") && ..SelectedEntity {
			
			// show the sources containing a particular entity (Module 3, exercise 6)
			set tSC = ##class(%iKnow.Queries.SourceAPI).GetByEntityIds("^News.Results.Sources", ..Domain, ..SelectedEntity, ..CurrentPage,, tFilter)
			set tTitle = "Articles containing ""<i>"_##class(%iKnow.Queries.EntityAPI).GetValue(..Domain, ..SelectedEntity)_"</i>"""_tTitle
			
		} else {
			
			// by default, just display the most recent articles
			set tSC = ##class(%iKnow.Queries.SourceAPI).GetByDomain("^News.Results.Sources", ..Domain, ..CurrentPage,, tFilter)
			set tTitle = "Recent articles"_tTitle
			
		}
		quit:$$$ISERR(tSC)
		
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:tTitle)
]]></Implementation>
</Method>

<Method name="DrawSource">
<Description>
Draws the main characteristics of a source in the main table</Description>
<FormalSpec>pTable:%ZEN.Component.tablePane,pName:%String,pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSourceId = %query("SourceId")
	set tExtId = %query("ExternalId")
	
	// by default, just output the article's title
	set tTitle = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "Title", tExtId)
	
	// if no title specified, take the first sentence
	if (tTitle="") {
		do ##class(%iKnow.Queries.SentenceAPI).GetBySource(.tSentences, ..Domain, tSourceId, 1, 1)
		set tTitle = $lg($g(tSentences(1)),2)
	}
	write tTitle
		
	// now write key entities / clusters (Module 3, exercise 6)
	//set tSC = ##class(%iKnow.Semantics.ProximityAPI).GetClustersBySource(.tEntities, ..Domain, tSourceId, 1, 5)
	//set tSC = ##class(%iKnow.Semantics.DominanceAPI).GetProfileBySource(.tEntities, ..Domain, tSourceId, 1, 5, $$$SDCONCEPT)
	set tSC = ##class(%iKnow.Queries.EntityAPI).GetTop(.tEntities, ..Domain, 1, 5, tSourceId)
	quit:$$$ISERR(tSC)
	if ($d(tEntities)) {
		write "<div class=""srcProfile"" >"
		set i = ""
		for {
			set i = $order(tEntities(i),1,tEntData)
			quit:i=""
			
			set tEntId = $li(tEntData,1)
			set tEntValue = $li(tEntData,2)
			
			// Gather related entities for this entity
			set tRelEntities = ""
			set tSC = ##class(%iKnow.Queries.EntityAPI).GetRelatedById(.tRelEnts, ..Domain, tEntId, 1, 5)
			quit:$$$ISERR(tSC)
			set j = ""
			for {
				set j = $order(tRelEnts(j), 1, tRelEntData)
				quit:j=""
				set:j>1 tRelEntities = tRelEntities _ " - "
				set tRelEntities = tRelEntities _ $li(tRelEntData,2)
			}
		
			write:i>1 " -"
			write " <a title=""",tRelEntities,""" href=""javascript:zenPage.showByEntity(",tEntId,");"">", tEntValue, "</a>"
			
			// Display "add as favorite" button
			write:..FavoritesDictionary'="" "<a href=""#"" onclick=""zenPage.addFavorite('",tEntValue,"', 'entity');""><img src=""deepsee/ds2_star_44.png"" height=""15"" title=""Add as a favorite"" /></a>"
		}
		write "</div>"
	}
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawSourceMeta">
<Description><![CDATA[
Draws a metadata field (passed in through <var>pSeed</var>) for a source in the main table]]></Description>
<FormalSpec>pTable:%ZEN.Component.tablePane,pName:%String,pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tExtId = %query("ExternalId")
	
	write ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, pSeed, tExtId)
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawSourceMetaDate">
<Description><![CDATA[
Draws a metadata date field (passed in through <var>pSeed</var>) for a source in the main table, shows date and time format]]></Description>
<FormalSpec>pTable:%ZEN.Component.tablePane,pName:%String,pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tExtId = %query("ExternalId")	
	
	set date = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, pSeed, tExtId)
	write $ZDATETIME(date, 1,1)
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawSourceActions">
<Description>
Draws the action buttons for a source in the main table</Description>
<FormalSpec>pTable:%ZEN.Component.tablePane,pName:%String,pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tExtId = %query("ExternalId"), tSrcId = %query("SourceId")
	
	write "<a href=""#"" onclick=""zenPage.readArticle(" _ tSrcId _ ");"" title=""Show article""><img src=""deepsee/ds2_glasses_44.png"" class=""action"" /></a>"
	write "&nbsp;&nbsp;<a href=""#"" onclick=""zenPage.showSimilar(" _ tSrcId _ ");"" title=""Show similar articles""><img src=""deepsee/ds2_radar_44.png"" class=""action"" /></a>"
	write "&nbsp;&nbsp;<a href=""#"" onclick=""zenPage.showMatches(" _ tSrcId _ ");"" title=""Show matches""><img src=""deepsee/ds2_palette_44.png"" class=""action"" /></a>"
	
	set tLink = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "Link", tExtId)
	if (tLink '= "") {
		write "&nbsp;&nbsp;<a href=""" _ tLink _ """ title=""Go to website""><img src=""deepsee/ds2_action_44.png"" class=""action"" /></a>"
	}
	
	if (..FavoritesDictionary'="") {
		write "&nbsp;&nbsp;<a href=""#"" onclick=""zenPage.addFavorite("_tSrcId_", 'source');"" title=""Add as favourite""><img src=""deepsee/ds2_star_44.png"" class=""action"" /></a>"
	}
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawArticle">
<Description>
Display the article contents in the article reading popup</Description>
<FormalSpec>pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:'..SelectedSource
		
		// If a summary length is specified, display a summary instead (Module 3, exercise 6)
		if ('..SummaryLength) {
			set tSC = ##class(%iKnow.Queries.SentenceAPI).GetBySource(.tSentences, ..Domain, ..SelectedSource, 0, 0)
		} else {
			
			set tSC = ##class(%iKnow.Queries.SourceAPI).GetSummary(.tSentences, ..Domain, ..SelectedSource, ..SummaryLength)
		}
		quit:$$$ISERR(tSC)
		
		// translate sentence IDs to positions (Module 4, exercise 3)
		set tSource = ##class(%iKnow.Objects.Source).PKINDEXOpen(..Domain, ..SelectedSource)
		for tSentPos = 1:1:tSource.FirstSentenceId+tSource.SentenceCount {
			set tSentId = tSource.FirstSentenceId + tSentPos - 1
			set tSentMap(tSentId) = tSentPos
		}
		
		set:..SelectedEntity tHighlights("ENTITY", ..SelectedEntity) = "<b>"
		set tHighlights("MATCH") = "<span class=""matchF"">"
		set tHighlights("MATCH", "PARTIAL") = "<span class=""matchP"">"
		
		write "<p>"
		
		set i = ""
		for {
			set i = $order(tSentences(i), 1, tSentData)
			quit:i=""
			
			set tSentID = $li(tSentData,1)
			
			// Get the highlighted version of a sentence (Module 4, exercise 3)
			write !,##class(%iKnow.Queries.SentenceAPI).GetHighlighted(..Domain, tSentID, .tHighlights,,,.tSC)
			quit:$$$ISERR(tSC)
		}
		
		write "</p>"
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="IndexArticle">
<Description><![CDATA[
This method is called by <method>submitInput</method> and will index the submitted text
<var>pText</var> using direct text loading.]]></Description>
<FormalSpec>pTitle:%String,pText:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// Instantiate a Loader object (Module 2, Exercise 4)
		set tLoader = ##class(%iKnow.Source.Loader).%New(..Domain)
		
		// Buffer and process the text, using the title as local ref
		set tRef = pTitle
		set tSC = tLoader.BufferSource(tRef, pText)
		quit:$$$ISERR(tSC)
		set tSC = tLoader.ProcessBuffer(..InputConfig)
		quit:$$$ISERR(tSC)
		
		// Retrieve the Source ID and External ID of the newly created source
		set tSourceId = $lg(tLoader.GetSourceIds(),1)
		set tNewExtId = ##class(%iKnow.Queries.SourceAPI).GetExternalId(..Domain, tSourceId)
		
		// Set appropriate metadata values (Module 3, Exercise 4)
		set tSC = ##class(%iKnow.Queries.MetadataAPI).SetValue(..Domain, "Title", tNewExtId, pTitle)
		quit:$$$ISERR(tSC)
		set tSC = ##class(%iKnow.Queries.MetadataAPI).SetValue(..Domain, "Agency", tNewExtId, "Manual input")
		quit:$$$ISERR(tSC)
		set tSC = ##class(%iKnow.Queries.MetadataAPI).SetValue(..Domain, "PubDate", tNewExtId, $horolog)
		quit:$$$ISERR(tSC)
		
		// Match the source (Module 4, Exercise 3)
		set tSC = ##class(%iKnow.Matching.MatchingAPI).MatchSource(..Domain, tSourceId)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<Method name="AddFavoriteTerm">
<Description>
Add favorite term to the Favorites dictionary, indexing all sources at the end
Module 4, exercise 5</Description>
<FormalSpec>pTerm:%String,pMatch:%Boolean=1</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:..FavoritesDictionary=""
		set tURI = ":favorites:"_$$$LOWER(pTerm)
		
		// find the ID for the "My Favorites" dictionary and add pTerm as an item and term,
		/// using tURI as its URI
		set tDictId = ##class(%iKnow.Matching.DictionaryAPI).GetDictionaryId(..Domain, ..FavoritesDictionary, .tSC)
		set:tDictId<=0 tDictId = ##class(%iKnow.Matching.DictionaryAPI).CreateDictionary(..Domain, ..FavoritesDictionary,,,, .tSC)
		quit:$$$ISERR(tSC)
		
		set tDictItemId = ##class(%iKnow.Matching.DictionaryAPI).CreateDictionaryItemAndTerm(..Domain, tDictId, pTerm, tURI,, .tSC)
		quit:$$$ISERR(tSC)
		
		if (pMatch) {
			set tSC = ##class(%iKnow.Matching.MatchingAPI).MatchSources(..Domain)
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<Method name="AddFavoriteSource">
<Description>
Add the top entities in a whole source as favorite terms to the Favorites dictionary
Module 4, exercise 5</Description>
<FormalSpec>pSourceId:%Integer,pCount:%Integer=5</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:..FavoritesDictionary=""
		
		// find the top <pCount> entities for a source and add them to the favorites
		// dictionary using AddFavoriteTerm()
		set tSC = ##class(%iKnow.Queries.EntityAPI).GetTop(.tEntities, ..Domain, 1, pCount, pSourceId)
		quit:$$$ISERR(tSC)
		
		set i = ""
		for {
			set i = $order(tEntities(i), 1, tEntData)
			quit:i=""
			
			set tRes = ..AddFavoriteTerm($li(tEntData,2), 0)
			if (tRes'="OK") { set tSC = $$$ERROR($$$GeneralError, tRes) quit }
		}
		quit:$$$ISERR(tSC)
		
		set tSC = ##class(%iKnow.Matching.MatchingAPI).MatchSources(..Domain)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<Method name="RefreshTablesTopDict">
<Description>
Utility method to get the top sources for a dictionary, lacking a
MatchingAPI.GetTopSources() method (Module 4, exercise 5)</Description>
<FormalSpec>pDictName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set:pDictName="" pDictName = ..FavoritesDictionary
		
		k ^News.Results.Sources
		
		// we'll solve this through a query on the raw match results table:
		//		- group by source ID
		//		- apply a filter for Agency, if required
		//		- add external ID to fit into target table
		//		- generate a pseudo-ID that will preserve sort order in target table
		set tSQL = "INSERT INTO iknowAV_view.Sources (ResultId, SourceId, ExternalId) SELECT -(FLOOR(TotalScore*1000)*1000+SourceId) PseudoId, SourceId, ExternalId FROM ("_
					" SELECT top 10 SourceId, %IKNOW_QUERIES.SOURCEQAPI_GETEXTERNALID("_..Domain_",SourceId) ExternalId, sum(MatchScore) TotalScore FROM "_
					" (SELECT Sentence->Source->SourceId SourceId, MatchScore FROM %iKnow_OBJECTS.DictionaryMatch "_
					" WHERE Dictionary->Name = '"_pDictName_"' AND DomainId = "_..Domain_")"
					
		if (..Agency'="") {
			set tSQL = tSQL _ " WHERE SourceId IN (SELECT SourceId FROM %iKnow_Objects.MetadataValue WHERE Field->Name = 'Agency' AND %SQLUPPER(Value) = %SQLUPPER('"_..Agency_"') AND DomainId = "_..Domain_")"
		}
					
		set tSQL = tSQL _ " GROUP BY SourceId ORDER BY TotalScore DESC)"
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		
		do tStatement.%Execute()
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<Description>
Ensure the main table is refreshed when opening the page a first time</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ..RefreshTables()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetArticleInfo">
<Description>
Utility method: return information about the current source as a proxy object</Description>
<ReturnType>%ZEN.proxyObject</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tObj = ##class(%ZEN.proxyObject).%New()
	set tObj.sourceId = ..SelectedSource
	set tObj.externalId = ##class(%iKnow.Queries.SourceAPI).GetExternalId(..Domain, ..SelectedSource)
	set tObj.title = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "Title", tObj.externalId)
	set tObj.pubDate = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "PubDate", tObj.externalId)
	set tObj.Agency = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "Agency", tObj.externalId)
	quit tObj
]]></Implementation>
</Method>

<Method name="reset">
<Description>
Resets the current action</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('CurrentAction', '');
	sc = zenPage.setProperty('Agency', '');
	sc = zenPage.setProperty('Category', '');
	sc = zenPage.setProperty('Topic', '');
	sc = zenPage.setProperty('CurrentPage', 1);
	zen('selAgency').setValue('');
	zen('selCategory').setValue('');
	zen('selTopic').setValue('');
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="showSimilar">
<Description>
Triggers the "similarSources" action</Description>
<FormalSpec>srcId</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SelectedSource', srcId);
	sc = zenPage.setProperty('CurrentPage', 1);
	sc = zenPage.setProperty('CurrentAction', 'similarSources');
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="showByEntity">
<Description>
Triggers the "byEntity" action</Description>
<FormalSpec>entId</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SelectedEntity', entId);
	sc = zenPage.setProperty('CurrentPage', 1);
	sc = zenPage.setProperty('CurrentAction', 'byEntity');
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="nextPage">
<Description>
Browse to the next page</Description>
<FormalSpec>direction</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var page = parseInt(zenPage.getProperty('CurrentPage')) + direction;
	if (page<=0) { page = 1 }
	var sc = zenPage.setProperty('CurrentPage', page);
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="readArticle">
<Description>
Opens the article reading popup</Description>
<FormalSpec>srcId</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SelectedSource', srcId);
	var obj = zenPage.GetArticleInfo();
	zen('titArticle').setProperty('title', obj.title);
	zen('titArticle').refreshContents();
	zen('htmlArticle').refreshContents();
	zen('modArticle').show();
]]></Implementation>
</Method>

<Method name="readAnyArticle">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	//var srcId = 1
	var srcId = zen('txtArticleId').getValue()
	var sc = zenPage.setProperty('SelectedSource', srcId);
	var obj = zenPage.GetArticleInfo();
	zen('titShowArticle').setProperty('title', obj.title);
	zen('titShowArticle').refreshContents();
	zen('htmlShowArticle').refreshContents();
	zen('modShowArticle').show();
]]></Implementation>
</Method>

<Method name="showMatches">
<Description>
Opens the article reading popup
Opens the matches detail popup</Description>
<FormalSpec>srcId</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SelectedSource', srcId);
	zen('tblDictScores').refreshContents();
	zen('modMatches').show();
]]></Implementation>
</Method>

<Method name="summarize">
<Description>
In the article reading pane, refresh the article to display a summary of the selected length</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SummaryLength', zen('txtSummaryLength').getValue());
	zen('htmlArticle').refreshContents();
]]></Implementation>
</Method>

<Method name="showArticle">
<Description>
In the article reading pane, refresh the article to display a summary of the selected length</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SelectedSource', zen('txtArticleId').getValue());
	zen('htmlShowArticle').refreshContents();
]]></Implementation>
</Method>

<Method name="submitInput">
<Description>
This method is called when manual input is being submitted</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var title = zen('txtInputTitle').getValue();
	var text = zen('txtInputText').getValue();
	var sc = zenPage.IndexArticle(title, text);
	if (sc != 'OK') { alert(sc); }
	zenPage.endModal();
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="addFavorite">
<Description>
Drives adding favourites</Description>
<FormalSpec>favorite,type</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (type == 'entity') {
		var sc = zenPage.AddFavoriteTerm(favorite, 1);
	} else {
		var sc = zenPage.AddFavoriteSource(favorite);
	}
	if (sc != 'OK') { alert(sc); }
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="onChangeDomain">
<Description>
Utility method: refresh current view based on current filter values</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// viart
	var sc = zenPage.setProperty('Domain', zen('selDomain').getValue());
	zenPage.refreshContents();
]]></Implementation>
</Method>

<Method name="onChangeFilters">
<Description>
Utility method: refresh current view based on current filter values</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('Domain', zen('selDomain').getValue());
	var sc = zenPage.setProperty('Agency', zen('selAgency').getValue());
	var sc = zenPage.setProperty('Category', zen('selCategory').getValue());
	var sc = zenPage.setProperty('Topic', zen('selTopic').getValue());
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="refreshAll">
<Description>
Utility method: refresh the main sources table and page subtitle</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var title = zenPage.RefreshTables();
	zen('lblSubtitle').setProperty('label', title);
	zen('tblSources').refreshContents();
]]></Implementation>
</Method>

<Method name="goToUI">
<Description>
Utility method: browse to a %iKnow.UI page</Description>
<FormalSpec>page</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var url = '_iKnow.UI.'+page+'.zen?&domain=' + zenPage.Domain + '&source=' + zenPage.SelectedSource;
	location.href = url;
]]></Implementation>
</Method>

<XData name="Style">
<Description>
Additional CSS styling for this page</Description>
<Data><![CDATA[
<style type="text/css">
body {
	padding: 20px;
	font-family: Calibri, Verdana;
}

.tpAction a:link {
	color: #A00000;
	text-decoration: none;
}
.tpAction a:hover {
	text-decoration: underline;
}

img.action {
	height: 22px;
}

.articleText {
	margin-top: 10px;
	margin-bottom: 10px;
	padding: 10px;
	border: 1px solid black;
	background: #ffffff;
}

.articleText p {
	margin-top: 10px;
	line-height: 1.3;
}

.matchF {
	border: 2px solid #FF9966;
	padding-right: 2px;
	padding-left: 2px;
	background: #FF9966;
}
.matchP {
	border: 2px solid #FF9966;
	padding-right: 2px;
	padding-left: 2px;
}

.srcProfile {
	margin-top: 10px;
	text-align: right;
	white-space: normal;
}

</style>
]]></Data>
</XData>
</Class>


<Class name="iknowAV.view.ReaderFixed">
<IncludeCode>%IKInclude</IncludeCode>
<Super>%ZEN.Component.page</Super>
<TimeChanged>63377,69416.558942</TimeChanged>
<TimeCreated>62810,43692.246071</TimeCreated>

<Property name="Domain">
<Type>%Integer</Type>
</Property>

<Property name="CurrentPage">
<Description>
ID of the domain used by this demo
Current page of results</Description>
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="PageSize">
<Type>%Integer</Type>
<InitialExpression>15</InitialExpression>
</Property>

<Property name="CurrentAction">
<Description>
Current action, as selected by the user</Description>
<Type>%String</Type>
</Property>

<Property name="SelectedSource">
<Description>
Source ID as selected by the user when clicking on an action</Description>
<Type>%Integer</Type>
</Property>

<Property name="Agency">
<Description>
Agency filter, if selected by the user (Module 3, exercise 4)</Description>
<Type>%String</Type>
</Property>

<Property name="SummaryLength">
<Description>
Length of the summary to be displayed in the article reading pane (Module 3, exercise 6)</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SelectedEntity">
<Description>
Entity ID as selected by the user when clicking on an entity (Module 3, exercise 6)</Description>
<Type>%Integer</Type>
</Property>

<Property name="Topic">
<Description>
Topic filter, if selected by the user (Module 4, exercise 4)</Description>
<Type>%String</Type>
</Property>

<Property name="Date">
<Description>
Date filter, if selected by the user (Module 4, exercise 4)</Description>
<Type>%String</Type>
</Property>

<Property name="Category">
<Description>
Category filter, if selected by the user (Module 4, exercise 4)</Description>
<Type>%String</Type>
</Property>

<Property name="FavoritesDictionary">
<Description>
Name of the dictionary containing "favorite terms" (Module 4, exercise 5)</Description>
<Type>%String</Type>
<InitialExpression>"My Favorites"</InitialExpression>
</Property>

<Property name="Subtitle">
<Description><![CDATA[
Subtitle, as derived by <method>RefreshTables</method>]]></Description>
<Type>%String</Type>
<InitialExpression>"Recent articles"</InitialExpression>
</Property>

<Property name="InputConfig">
<Description>
Name of the configuration to use for indexing manual input</Description>
<Type>%String</Type>
<InitialExpression>"AllLanguages"</InitialExpression>
</Property>

<XData name="Contents">
<XMLNamespace>http://www.intersystems.com/zen</XMLNamespace>
<Data><![CDATA[
<page title="News reader" layout="vertical" width="100%" height="100%" >
<titleBox title="News reader" titleStyle="font-size: 28px;" />
<hgroup width="100%" cellVAlign="middle">
<label id="lblSubtitle" label="#(%page.Subtitle)#" width="80%"
labelStyle="font-size: 20px;" />
<spacer width="5" />

<select label="Domain" id="selDomain"
queryClass="%iKnow.Domain" queryName="GetAllDomains"  showEmpty="false" 
onchange="zenPage.onChangeDomain();">
<parameter value="#(%page.Domain)#" />
</select>
<spacer width="10" />
<select label="Agency" id="Agency"
queryClass="%iKnow.Queries.MetadataQAPI" queryName="GetFieldValues"
onchange="zenPage.onChangeFilters();">
<parameter value="#(%page.Domain)#" />
<parameter value="Agency" />
</select>
<spacer width="10" />
<select label="Category" id="selCategory"
queryClass="%iKnow.Queries.MetadataQAPI" queryName="GetFieldValues"
onchange="zenPage.onChangeFilters();">
<parameter value="#(%page.Domain)#" />
<parameter value="Category" />
</select>
<spacer width="10" />
<select label="Topic" id="selTopic"
queryClass="%iKnow.Matching.DictionaryQAPI" queryName="GetDictionaries"
onchange="zenPage.onChangeFilters();">
<parameter value="#(%page.Domain)#" />
</select>
<spacer width="10" />
<image src="deepsee/ds2_compose_44.png" enclosingStyle="padding-top:5px;"
   onclick="zen('modInput').show();" height="40" />
<spacer width="10" />
<image src="deepsee/ds2_bookmarks_44.png" enclosingStyle="padding-top:5px;"
  onclick ="zen('showArticle').show();"
   height="40" />
<spacer width="10" />
<image src="deepsee/ds2_house_44.png" enclosingStyle="padding-top:5px;"
   onclick="zenPage.reset();" height="40" />
</hgroup>
<spacer height="20" />
<tablePane id="tblSources" caption="Articles" rowSelect="false" showRowSelector="false" nowrap="0"
sql="SELECT SourceId, ExternalId FROM iknowAV_view.Sources" width="100%">
<column colName="ID" hidden="true" />
<column colName="ExternalId" hidden="true" />
<column header="Date" OnDrawCell="DrawSourceMetaDate" seed="PubDate" style="text-align:center;" />
<column header="Title" OnDrawCell="DrawSource" style="padding:5px; white-space:normal;"   />
<column header="Agency" OnDrawCell="DrawSourceMeta" seed="Agency" />
<column header="Category" OnDrawCell="DrawSourceMeta" seed="Category" />
<column header="Actions" OnDrawCell="DrawSourceActions" style="text-align:center;" />
</tablePane>
<hgroup width="100%" cellAlign="right" id="pageControls">
<button caption="&lt;&lt;" onclick="zenPage.nextPage(-1);" />
<spacer width="5" />
<button caption="&gt;&gt;" onclick="zenPage.nextPage(+1);" />
<spacer width="5" />
<text id="PageSize" value="15" name="PageSize"/>
<spacer width="5" />
<button caption="Update Pagesize" name="Submit" onclick="zenPage.refreshAll()"/>
<spacer width="5" />
</hgroup>

<modalGroup id="modArticle" >
<titleBox id="titArticle" />
<vgroup enclosingClass="articleText">
<html id="htmlArticle" OnDrawContent="DrawArticle" />
<hgroup cellAlign="right" width="100%" labelPosition="left">
<text title="Summary length" size="2" id="txtSummaryLength" onkeyup="zenPage.summarize();" />
<spacer width="20" />
<image src="deepsee/ds2_notepad_44.png" height="22" title="Indexing results"
	onclick="zenPage.goToUI('IndexingResults');" />
<spacer width="10" />
<image src="deepsee/ds2_palette_44.png" height="22" title="Matching results"
	onclick="zenPage.goToUI('MatchingResults');" />
</hgroup>
</vgroup>
</modalGroup>

<modalGroup id="showArticle" >
<titleBox id="titShowArticle" />
<vgroup enclosingClass="articleText">
<html id="htmlShowArticle" OnDrawContent="DrawArticle" />
<hgroup cellAlign="right" width="100%" labelPosition="left">
<text title="Summary length" size="2" id="txtArticleId" />
<spacer width="20" />
<button caption="show" onclick="zenPage.showArticle();" />
</hgroup>
</vgroup>
</modalGroup>

<modalGroup id="modInput" width="400px" labelPosition="left" cellStyle="padding-bottom:8px">
<titleBox title="Manual input" width="70%"/>
<text id="txtInputTitle" label="Title" size="50" />
<textarea id="txtInputText" cols="80" rows="10" width="70%" label="Article" />
<hgroup cellAlign="right" width="100%">
<button caption="save" onclick="zenPage.submitInput();" />
</hgroup>
</modalGroup>

<modalGroup id="modMatches" >
<titleBox title="Matching results" />
<spacer height="10" />
<tablePane id="tblDictScores" 
queryClass="%iKnow.Matching.MatchingQAPI" queryName="GetTotalDictionaryScoresBySourceId">
<parameter value="#(%page.Domain)#" />
<parameter value="#(%page.SelectedSource)#" />
</tablePane>
</modalGroup>

</page>
]]></Data>
</XData>

<Method name="RefreshTables">
<Description>
Refreshes the contents of the main sources table based on the values of the different page
properties containing the current action, user selections and filter criteria</Description>
<ReturnType>%Status</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK, tTitle = ""
	try {
		
		// create filter object (Module 3, exercise 4)
		set tFilter = ""
		if (..Agency '= "") {
			set tFilter = ##class(%iKnow.Filters.SimpleMetadataFilter).%New(..Domain, "Agency", "=", ..Agency)
			set tTitle = " ("_..Agency_")"
		}
		
		if (..Category '= "") {
			
			set tFilterCategory = ##class(%iKnow.Filters.SimpleMetadataFilter).%New(..Domain, "Category", "=", ..Category)
			
			if (tFilter = "") {
				set tFilter = tFilterCategory
			}
			else {
				set tempFilter = ##class(%iKnow.Filters.GroupFilter).%New(..Domain)
				do tempFilter.AddSubFilter(tFilter)
				do tempFilter.AddSubFilter(tFilterCategory)
				set tFilter = tempFilter
			}
			
			
			set tTitle = tTitle _ " ("_..Category_")"
		}
		
		// append a topic filter if required (Module 4, exercise 4)
		if (..Topic '= "") {
			
			set tFilter2 = ##class(%iKnow.Filters.SimpleMatchFilter).%New(..Domain, ..Topic, 1)
			
			// combine filters
			if (tFilter="") {
				set tFilter = tFilter2
			} else {
				set tGrpFilter = ##class(%iKnow.Filters.GroupFilter).%New(..Domain, 1)
				do tGrpFilter.AddSubFilter(tFilter)
				do tGrpFilter.AddSubFilter(tFilter2)
				set tFilter = tGrpFilter
			}
			
			// retrieve dictionary name
			set tDict = ##class(%iKnow.Objects.Dictionary).PKINDEXOpen(..Domain, ..Topic)
			set tTitle = tTitle _ " ("_tDict.Name_")"
			
			
			// forward to RefreshTablesTopDict for favorites dictionary
			if (tDict.Name = ..FavoritesDictionary) {
				set tTitle = "My Favorites" _ tTitle
				set tSC = ..RefreshTablesTopDict(tDict.Name)
				quit // always quit, we populated the table inside RefreshTablesTopDict()
			}
			
		}
		
		// populate sources table
		if (..CurrentAction = "similarSources") && ..SelectedSource {
			
			set tSelSourceExtId = ##class(%iKnow.Queries.SourceAPI).GetExternalId(..Domain, ..SelectedSource)
			set tSelSourceTitle = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "Title", tSelSourceExtId)
			
			// show the sources similar to ..SelectedSource (Module 3, exercise 4)
			set tSC = ##class(%iKnow.Queries.SourceAPI).GetSimilar("^News.Results.Sources", ..Domain, ..SelectedSource, ..CurrentPage, ..PageSize, tFilter)
			set tTitle = "Articles related to ""<i>"_tSelSourceTitle_"</i>"""_tTitle
			
		} elseif (..CurrentAction = "byEntity") && ..SelectedEntity {
			
			// show the sources containing a particular entity (Module 3, exercise 6)
			set tSC = ##class(%iKnow.Queries.SourceAPI).GetByEntityIds("^News.Results.Sources", ..Domain, ..SelectedEntity, ..CurrentPage, ..PageSize, tFilter)
			set tTitle = "Articles containing ""<i>"_##class(%iKnow.Queries.EntityAPI).GetValue(..Domain, ..SelectedEntity)_"</i>"""_tTitle
			
		} else {
			
			// by default, just display the most recent articles
			set tSC = ##class(%iKnow.Queries.SourceAPI).GetByDomain("^News.Results.Sources", ..Domain, ..CurrentPage, ..PageSize, tFilter)
			set tTitle = "Recent articles"_tTitle
			
		}
		quit:$$$ISERR(tSC)
		
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:tTitle)
]]></Implementation>
</Method>

<Method name="DrawSource">
<Description>
Draws the main characteristics of a source in the main table</Description>
<FormalSpec>pTable:%ZEN.Component.tablePane,pName:%String,pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSourceId = %query("SourceId")
	set tExtId = %query("ExternalId")
	
	// by default, just output the article's title
	set tTitle = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "Title", tExtId)
	
	// if no title specified, take the first sentence
	if (tTitle="") {
		do ##class(%iKnow.Queries.SentenceAPI).GetBySource(.tSentences, ..Domain, tSourceId, 1, 1)
		set tTitle = $lg($g(tSentences(1)),2)
	}
	write tTitle
		
	// now write key entities / clusters (Module 3, exercise 6)
	//set tSC = ##class(%iKnow.Semantics.ProximityAPI).GetClustersBySource(.tEntities, ..Domain, tSourceId, 1, 5)
	//set tSC = ##class(%iKnow.Semantics.DominanceAPI).GetProfileBySource(.tEntities, ..Domain, tSourceId, 1, 5, $$$SDCONCEPT)
	set tSC = ##class(%iKnow.Queries.EntityAPI).GetTop(.tEntities, ..Domain, 1, 5, tSourceId)
	quit:$$$ISERR(tSC)
	if ($d(tEntities)) {
		write "<div class=""srcProfile"" >"
		set i = ""
		for {
			set i = $order(tEntities(i),1,tEntData)
			quit:i=""
			
			set tEntId = $li(tEntData,1)
			set tEntValue = $li(tEntData,2)
			
			// Gather related entities for this entity
			set tRelEntities = ""
			set tSC = ##class(%iKnow.Queries.EntityAPI).GetRelatedById(.tRelEnts, ..Domain, tEntId, 1, 5)
			quit:$$$ISERR(tSC)
			set j = ""
			for {
				set j = $order(tRelEnts(j), 1, tRelEntData)
				quit:j=""
				set:j>1 tRelEntities = tRelEntities _ " - "
				set tRelEntities = tRelEntities _ $li(tRelEntData,2)
			}
		
			write:i>1 " -"
			write " <a title=""",tRelEntities,""" href=""javascript:zenPage.showByEntity(",tEntId,");"">", tEntValue, "</a>"
			
			// Display "add as favorite" button
			write:..FavoritesDictionary'="" "<a href=""#"" onclick=""zenPage.addFavorite('",tEntValue,"', 'entity');""><img src=""deepsee/ds2_star_44.png"" height=""15"" title=""Add as a favorite"" /></a>"
		}
		write "</div>"
	}
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawSourceMeta">
<Description><![CDATA[
Draws a metadata field (passed in through <var>pSeed</var>) for a source in the main table]]></Description>
<FormalSpec>pTable:%ZEN.Component.tablePane,pName:%String,pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tExtId = %query("ExternalId")
	
	write ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, pSeed, tExtId)
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawSourceMetaDate">
<Description><![CDATA[
Draws a metadata date field (passed in through <var>pSeed</var>) for a source in the main table, shows date and time format]]></Description>
<FormalSpec>pTable:%ZEN.Component.tablePane,pName:%String,pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tExtId = %query("ExternalId")	
	
	set date = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, pSeed, tExtId)
	write $ZDATETIME(date, 1,1)
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawSourceActions">
<Description>
Draws the action buttons for a source in the main table</Description>
<FormalSpec>pTable:%ZEN.Component.tablePane,pName:%String,pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tExtId = %query("ExternalId"), tSrcId = %query("SourceId")
	
	write "<a href=""#"" onclick=""zenPage.readArticle(" _ tSrcId _ ");"" title=""Show article""><img src=""deepsee/ds2_glasses_44.png"" class=""action"" /></a>"
	write "&nbsp;&nbsp;<a href=""#"" onclick=""zenPage.showSimilar(" _ tSrcId _ ");"" title=""Show similar articles""><img src=""deepsee/ds2_radar_44.png"" class=""action"" /></a>"
	write "&nbsp;&nbsp;<a href=""#"" onclick=""zenPage.showMatches(" _ tSrcId _ ");"" title=""Show matches""><img src=""deepsee/ds2_palette_44.png"" class=""action"" /></a>"
	
	set tLink = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "Link", tExtId)
	if (tLink '= "") {
		write "&nbsp;&nbsp;<a href=""" _ tLink _ """ title=""Go to website""><img src=""deepsee/ds2_action_44.png"" class=""action"" /></a>"
	}
	
	if (..FavoritesDictionary'="") {
		write "&nbsp;&nbsp;<a href=""#"" onclick=""zenPage.addFavorite("_tSrcId_", 'source');"" title=""Add as favourite""><img src=""deepsee/ds2_star_44.png"" class=""action"" /></a>"
	}
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawArticle">
<Description>
Display the article contents in the article reading popup</Description>
<FormalSpec>pSeed:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:'..SelectedSource
		
		// If a summary length is specified, display a summary instead (Module 3, exercise 6)
		if ('..SummaryLength) {
			set tSC = ##class(%iKnow.Queries.SentenceAPI).GetBySource(.tSentences, ..Domain, ..SelectedSource, 0, 0)
		} else {
			
			set tSC = ##class(%iKnow.Queries.SourceAPI).GetSummary(.tSentences, ..Domain, ..SelectedSource, ..SummaryLength)
		}
		quit:$$$ISERR(tSC)
		
		// translate sentence IDs to positions (Module 4, exercise 3)
		set tSource = ##class(%iKnow.Objects.Source).PKINDEXOpen(..Domain, ..SelectedSource)
		for tSentPos = 1:1:tSource.FirstSentenceId+tSource.SentenceCount {
			set tSentId = tSource.FirstSentenceId + tSentPos - 1
			set tSentMap(tSentId) = tSentPos
		}
		
		set:..SelectedEntity tHighlights("ENTITY", ..SelectedEntity) = "<b>"
		set tHighlights("MATCH") = "<span class=""matchF"">"
		set tHighlights("MATCH", "PARTIAL") = "<span class=""matchP"">"
		
		write "<p>"
		
		set i = ""
		for {
			set i = $order(tSentences(i), 1, tSentData)
			quit:i=""
			
			set tSentID = $li(tSentData,1)
			
			
			// Get the highlighted version of a sentence (Module 4, exercise 3)
			write !,##class(%iKnow.Queries.SentenceAPI).GetHighlighted(..Domain, tSentID, .tHighlights,,,.tSC)
			quit:$$$ISERR(tSC)
		}
		
		write "</p>"
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="IndexArticle">
<Description><![CDATA[
This method is called by <method>submitInput</method> and will index the submitted text
<var>pText</var> using direct text loading.]]></Description>
<FormalSpec>pTitle:%String,pText:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		// Instantiate a Loader object (Module 2, Exercise 4)
		set tLoader = ##class(%iKnow.Source.Loader).%New(..Domain)
		
		// Buffer and process the text, using the title as local ref
		set tRef = pTitle
		set tSC = tLoader.BufferSource(tRef, pText)
		quit:$$$ISERR(tSC)
		set tSC = tLoader.ProcessBuffer(..InputConfig)
		quit:$$$ISERR(tSC)
		
		// Retrieve the Source ID and External ID of the newly created source
		set tSourceId = $lg(tLoader.GetSourceIds(),1)
		set tNewExtId = ##class(%iKnow.Queries.SourceAPI).GetExternalId(..Domain, tSourceId)
		
		// Set appropriate metadata values (Module 3, Exercise 4)
		set tSC = ##class(%iKnow.Queries.MetadataAPI).SetValue(..Domain, "Title", tNewExtId, pTitle)
		quit:$$$ISERR(tSC)
		set tSC = ##class(%iKnow.Queries.MetadataAPI).SetValue(..Domain, "Agency", tNewExtId, "Manual input")
		quit:$$$ISERR(tSC)
		set tSC = ##class(%iKnow.Queries.MetadataAPI).SetValue(..Domain, "PubDate", tNewExtId, $horolog)
		quit:$$$ISERR(tSC)
		
		// Match the source (Module 4, Exercise 3)
		set tSC = ##class(%iKnow.Matching.MatchingAPI).MatchSource(..Domain, tSourceId)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<Method name="AddFavoriteTerm">
<Description>
Add favorite term to the Favorites dictionary, indexing all sources at the end
Module 4, exercise 5</Description>
<FormalSpec>pTerm:%String,pMatch:%Boolean=1</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:..FavoritesDictionary=""
		set tURI = ":favorites:"_$$$LOWER(pTerm)
		
		// find the ID for the "My Favorites" dictionary and add pTerm as an item and term,
		/// using tURI as its URI
		set tDictId = ##class(%iKnow.Matching.DictionaryAPI).GetDictionaryId(..Domain, ..FavoritesDictionary, .tSC)
		set:tDictId<=0 tDictId = ##class(%iKnow.Matching.DictionaryAPI).CreateDictionary(..Domain, ..FavoritesDictionary,,,, .tSC)
		quit:$$$ISERR(tSC)
		
		set tDictItemId = ##class(%iKnow.Matching.DictionaryAPI).CreateDictionaryItemAndTerm(..Domain, tDictId, pTerm, tURI,, .tSC)
		quit:$$$ISERR(tSC)
		
		if (pMatch) {
			set tSC = ##class(%iKnow.Matching.MatchingAPI).MatchSources(..Domain)
			quit:$$$ISERR(tSC)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<Method name="AddFavoriteSource">
<Description>
Add the top entities in a whole source as favorite terms to the Favorites dictionary
Module 4, exercise 5</Description>
<FormalSpec>pSourceId:%Integer,pCount:%Integer=5</FormalSpec>
<ReturnType>%String</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		quit:..FavoritesDictionary=""
		
		// find the top <pCount> entities for a source and add them to the favorites
		// dictionary using AddFavoriteTerm()
		set tSC = ##class(%iKnow.Queries.EntityAPI).GetTop(.tEntities, ..Domain, 1, pCount, pSourceId)
		quit:$$$ISERR(tSC)
		
		set i = ""
		for {
			set i = $order(tEntities(i), 1, tEntData)
			quit:i=""
			
			set tRes = ..AddFavoriteTerm($li(tEntData,2), 0)
			if (tRes'="OK") { set tSC = $$$ERROR($$$GeneralError, tRes) quit }
		}
		quit:$$$ISERR(tSC)
		
		set tSC = ##class(%iKnow.Matching.MatchingAPI).MatchSources(..Domain)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit $s($$$ISERR(tSC):$system.Status.GetErrorText(tSC), 1:"OK")
]]></Implementation>
</Method>

<Method name="RefreshTablesTopDict">
<Description>
Utility method to get the top sources for a dictionary, lacking a
MatchingAPI.GetTopSources() method (Module 4, exercise 5)</Description>
<FormalSpec>pDictName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set:pDictName="" pDictName = ..FavoritesDictionary
		
		k ^News.Results.Sources
		
		// we'll solve this through a query on the raw match results table:
		//		- group by source ID
		//		- apply a filter for Agency, if required
		//		- add external ID to fit into target table
		//		- generate a pseudo-ID that will preserve sort order in target table
		set tSQL = "INSERT INTO iknowAV_view.Sources (ResultId, SourceId, ExternalId) SELECT -(FLOOR(TotalScore*1000)*1000+SourceId) PseudoId, SourceId, ExternalId FROM "_
					"(SELECT top 10 SourceId, %IKNOW_QUERIES.SOURCEQAPI_GETEXTERNALID("_..Domain_",SourceId) ExternalId, sum(MatchScore) TotalScore FROM "_
					" (SELECT Sentence->Source->SourceId SourceId, MatchScore FROM %iKnow_OBJECTS.DictionaryMatch "_
					" WHERE Dictionary->Name = '"_pDictName_"' AND DomainId = "_..Domain_")"
					
		if (..Agency '= "") {
			set tSQL = tSQL _ " WHERE SourceId IN (SELECT SourceId FROM %iKnow_Objects.MetadataValue WHERE Field->Name = 'Agency' AND %SQLUPPER(Value) = %SQLUPPER('"_..Agency_"') AND DomainId = "_..Domain_")"
		}
					
		set tSQL = tSQL _ " GROUP BY SourceId ORDER BY TotalScore DESC)"
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(tSC)
		
		
		
		do tStatement.%Execute()
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%OnAfterCreatePage">
<Description>
Ensure the main table is refreshed when opening the page a first time</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set resultSet = ##class(%ResultSet).%New()
	set resultSet.ClassName = "%iKnow.Domain"
	set resultSet.QueryName = "GetAllDomains"
	
	do resultSet.Execute(1)
	
	do resultSet.%Next()
	
	set ..Domain = resultSet.GetDataByName("domainId")
	
	do ..RefreshTables()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetArticleInfo">
<Description>
Utility method: return information about the current source as a proxy object</Description>
<ReturnType>%ZEN.proxyObject</ReturnType>
<ZenMethod>1</ZenMethod>
<Implementation><![CDATA[
	set tObj = ##class(%ZEN.proxyObject).%New()
	set tObj.sourceId = ..SelectedSource
	set tObj.externalId = ##class(%iKnow.Queries.SourceAPI).GetExternalId(..Domain, ..SelectedSource)
	set tObj.title = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "Title", tObj.externalId)
	set tObj.pubDate = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "PubDate", tObj.externalId)
	set tObj.Agency = ##class(%iKnow.Queries.MetadataAPI).GetValue(..Domain, "Agency", tObj.externalId)
	quit tObj
]]></Implementation>
</Method>

<Method name="reset">
<Description>
Resets the current action</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('CurrentAction', '');
	sc = zenPage.setProperty('Agency', '');
	sc = zenPage.setProperty('Category', '');
	sc = zenPage.setProperty('Topic', '');
	sc = zenPage.setProperty('CurrentPage', 1);
	zen('selAgency').setValue('');
	zen('selCategory').setValue('');
	zen('selTopic').setValue('');
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="showSimilar">
<Description>
Triggers the "similarSources" action</Description>
<FormalSpec>srcId</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SelectedSource', srcId);
	sc = zenPage.setProperty('CurrentPage', 1);
	sc = zenPage.setProperty('CurrentAction', 'similarSources');
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="showByEntity">
<Description>
Triggers the "byEntity" action</Description>
<FormalSpec>entId</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SelectedEntity', entId);
	sc = zenPage.setProperty('CurrentPage', 1);
	sc = zenPage.setProperty('CurrentAction', 'byEntity');
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="nextPage">
<Description>
Browse to the next page</Description>
<FormalSpec>direction</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var page = parseInt(zenPage.getProperty('CurrentPage')) + direction;
	if (page<=0) { page = 1 }
	var sc = zenPage.setProperty('CurrentPage', page);
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="readArticle">
<Description>
Opens the article reading popup</Description>
<FormalSpec>srcId</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SelectedSource', srcId);
	var obj = zenPage.GetArticleInfo();
	zen('titArticle').setProperty('title', obj.title);
	zen('titArticle').refreshContents();
	zen('htmlArticle').refreshContents();
	zen('modArticle').show();
]]></Implementation>
</Method>

<Method name="readAnyArticle">
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	//var srcId = 1
	var srcId = zen('txtArticleId').getValue()
	var sc = zenPage.setProperty('SelectedSource', srcId);
	var obj = zenPage.GetArticleInfo();
	zen('titShowArticle').setProperty('title', obj.title);
	zen('titShowArticle').refreshContents();
	zen('htmlShowArticle').refreshContents();
	zen('modShowArticle').show();
]]></Implementation>
</Method>

<Method name="showMatches">
<Description>
Opens the article reading popup
Opens the matches detail popup</Description>
<FormalSpec>srcId</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SelectedSource', srcId);
	zen('tblDictScores').refreshContents();
	zen('modMatches').show();
]]></Implementation>
</Method>

<Method name="summarize">
<Description>
In the article reading pane, refresh the article to display a summary of the selected length</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SummaryLength', zen('txtSummaryLength').getValue());
	zen('htmlArticle').refreshContents();
]]></Implementation>
</Method>

<Method name="showArticle">
<Description>
In the article reading pane, refresh the article to display a summary of the selected length</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('SelectedSource', zen('txtArticleId').getValue());
	zen('htmlShowArticle').refreshContents();
]]></Implementation>
</Method>

<Method name="submitInput">
<Description>
This method is called when manual input is being submitted</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var title = zen('txtInputTitle').getValue();
	var text = zen('txtInputText').getValue();
	var sc = zenPage.IndexArticle(title, text);
	if (sc != 'OK') { alert(sc); }
	zenPage.endModal();
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="addFavorite">
<Description>
Drives adding favourites</Description>
<FormalSpec>favorite,type</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	if (type == 'entity') {
		var sc = zenPage.AddFavoriteTerm(favorite, 1);
	} else {
		var sc = zenPage.AddFavoriteSource(favorite);
	}
	if (sc != 'OK') { alert(sc); }
	zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="onChangeDomain">
<Description>
Utility method: refresh current view based on current filter values</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	// viart
	var sc = zenPage.setProperty('Domain', zen('selDomain').getValue());
	sc = zenPage.setProperty('CurrentPage', 1)
	zenPage.refreshContents();
	sc = zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="onChangeFilters">
<Description>
Utility method: refresh current view based on current filter values</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('Domain', zen('selDomain').getValue());
	var sc = zenPage.setProperty('Agency', zen('Agency').getValue());
	var sc = zenPage.setProperty('Category', zen('selCategory').getValue());
	var sc = zenPage.setProperty('Topic', zen('selTopic').getValue());
	sc = zenPage.refreshAll();
]]></Implementation>
</Method>

<Method name="refreshAll">
<Description>
Utility method: refresh the main sources table and page subtitle</Description>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var sc = zenPage.setProperty('PageSize', zen('PageSize').getValue())
	var title = zenPage.RefreshTables();
	zen('lblSubtitle').setProperty('label', title);
	zen('tblSources').refreshContents();
]]></Implementation>
</Method>

<Method name="goToUI">
<Description>
Utility method: browse to a %iKnow.UI page</Description>
<FormalSpec>page</FormalSpec>
<Language>javascript</Language>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	var url = '_iKnow.UI.'+page+'.zen?&domain=' + zenPage.Domain + '&source=' + zenPage.SelectedSource;
	location.href = url;
]]></Implementation>
</Method>

<XData name="Style">
<Description>
Additional CSS styling for this page</Description>
<Data><![CDATA[
<style type="text/css">
body {
	padding: 20px;
	font-family: Calibri, Verdana;
}

#pageControls {
	padding-top: 7px;
	padding-bottom: 7px;
}

.tpAction a:link {
	color: #A00000;
	text-decoration: none;
}
.tpAction a:hover {
	text-decoration: underline;
}

.modalGroup {
	width: 70% !important;
	top: 200px !important;
	left: 15% !important;
	margin-bottom: 50px !important;
	height: auto !important;
	
}

img.action {
	height: 22px;
}

.articleText {
	margin-top: 10px;
	margin-bottom: 10px;
	padding: 10px;
	border: 1px solid black;
	background: #ffffff;
}

.articleText p {
	margin-top: 10px;
	line-height: 1.3;
}

.matchF {
	border: 2px solid #FF9966;
	padding-right: 2px;
	padding-left: 2px;
	background: #FF9966;
}
.matchP {
	border: 2px solid #FF9966;
	padding-right: 2px;
	padding-left: 2px;
}

.srcProfile {
	margin-top: 10px;
	text-align: right;
	white-space: normal;
}

</style>
]]></Data>
</XData>
</Class>


<Class name="iknowAV.view.Sources">
<StorageStrategy>CustomStorage</StorageStrategy>
<Super>%Persistent</Super>
<TimeChanged>63330,58214.592682</TimeChanged>
<TimeCreated>63330,58189.028816</TimeCreated>

<Property name="ResultId">
<Type>%Numeric</Type>
</Property>

<Property name="SourceId">
<Type>%Integer</Type>
</Property>

<Property name="ExternalId">
<Type>%String</Type>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Index name="PKINDEX">
<IdKey>1</IdKey>
<PrimaryKey>1</PrimaryKey>
<Properties>ResultId</Properties>
<Unique>1</Unique>
</Index>

<Storage name="CustomStorage">
<Type>%Library.CacheSQLStorage</Type>
<StreamLocation>^News.Results.SourcesS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<CounterLocation>^News.Results.SourcesINC</CounterLocation>
<SQLMap name="MainMap">
<Type>data</Type>
<Global>^News.Results.Sources</Global>
<Subscript name="1">
<Expression>{ResultId}</Expression>
</Subscript>
<Data name="ExternalId">
<Piece>2</Piece>
</Data>
<Data name="SourceId">
<Piece>1</Piece>
</Data>
</SQLMap>
</Storage>
</Class>
</Export>
